#pragma warning (disable : 4996)

// 문제 C4: [TST]N QUEEN
#if 0
#include <stdio.h>
#define MAX     (15)

typedef struct
{
	int y, x;
}NODE;
NODE List[MAX];

void Input(void);
void DFS(int L);
void Check_8(int r, int c, int num);
void Print_List(void);
void Print(void);

int N;
int Board[MAX][MAX];
int dy[8] = { -1, -1, -1, 0, 1, 1, 1, 0 };
int dx[8] = { -1, 0, 1, 1, 1, 0, -1, -1 };        // 8방 체크
int check0[MAX];
int check1[2 * MAX];    //              / 체크
int check2[2 * MAX];    //              \ 체크
int count;
int chk[MAX];

int main(void)
{
	Input();
	DFS(1);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	count = 0;
	scanf("%d", &N);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			Board[i][j] = 0;
		}
	}
}

void DFS(int L)
{
	int i;

	if (L > N)
	{
		count++;
		//printf("%d : ", count);
		//Print_List();
		return;
	}

	for (i = 1; i <= N; i++)
	{
		if (Board[L][i] == 0 && check0[i] == 0 && check1[L + i] == 0 && check2[i - L + N] == 0)
		{
			check0[i] = 1;
			check1[L + i] = 1;
			check2[i - L + N] = 1;
			Check_8(L, i, 1);
			List[L].y = L;
			List[L].x = i;

			DFS(L + 1);

			check0[i] = 0;
			check1[L + i] = 0;
			check2[i - L + N] = 0;
			Check_8(L, i, 0);
			List[L].y = 0;
			List[L].x = 0;
		}

	}
}

void Check_8(int r, int c, int num)
{
	int i, ny, nx;

	for (i = 0; i < 8; i++)
	{
		ny = r + dy[i];
		nx = c + dx[i];
		if (ny < 1 || ny > N || nx < 1 || nx > N) continue;
		Board[ny][nx] = num;
	}
}

void Print_List(void)
{
	int i;

	for (i = 1; i <= N; i++)
	{
		printf("y = %d, x = %d\n", List[i].y, List[i].x);
	}
	printf("\n\n");
}

void Print(void)
{
	printf("%d\n", count);
}
#endif



// 문제 C9: [TST] 먼 목초지
#if 0
#include <stdio.h>
#define MAX     (32)
#define INF     (987654321)

typedef struct
{
	int y, x;
}NODE;
NODE Q[MAX * MAX * 20];

void Input(void);
void InQ(int yy, int xx);
NODE * OutQ(void);
void Operation(void);
void FF_BFS(int sy, int sx);
int Find_Max(void);
void Init_Visit(void);
void Print(void);

int N, A, B;
int Mokcho[MAX][MAX];
int Visit[MAX][MAX];
int Wp, Rp;
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int Max_Time;

int main(void)
{
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;
	char tmp[MAX];

	scanf("%d %d %d", &N, &A, &B);
	for (i = 1; i <= N; i++)
	{
		scanf("%s", tmp);
		for (j = 1; j <= N; j++)
		{
			if (tmp[j - 1] == '(') Mokcho[i][j] = 1;
			else Mokcho[i][j] = 9;
		}
	}
}

void InQ(int yy, int xx)
{
	Q[Wp].y = yy;
	Q[Wp++].x = xx;
}

NODE * OutQ(void)
{
	return &(Q[Rp++]);
}

void FF_BFS(int sy, int sx)
{
	NODE * out = (NODE *)0x0;
	int i;
	int ny, nx;
	int check;

	Wp = Rp = 0;
	InQ(sy, sx);
	Visit[sy][sx] = 0;

	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;
		sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];
			nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > N) continue;
			if (Mokcho[sy][sx] == Mokcho[ny][nx]) check = Visit[sy][sx] + A;
			else check = Visit[sy][sx] + B;
			if (Visit[ny][nx] > check)
			{
				Visit[ny][nx] = check;
				InQ(ny, nx);
			}
		}
	}
}

int Find_Max(void)
{
	int i, j;
	int max = 0;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			if (max < Visit[i][j]) max = Visit[i][j];
		}
	}

	return max;
}

void Operation(void)
{
	int i, j;
	int max;

	Max_Time = 0;
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			Init_Visit();
			FF_BFS(i, j);
			max = Find_Max();
			if (Max_Time < max) Max_Time = max;
		}
	}
}

void Init_Visit(void)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			Visit[i][j] = INF;
		}
	}
}

void Print(void)
{
	//        int i, j;

	//        for(i = 1; i <= N; i++)
	//        {
	//                for(j = 1; j <= N; j++)
	//                {
	//                        printf("%d ", Mokcho[i][j]);
	//                }
	//                printf("\n");
	//        }

	printf("%d\n", Max_Time);
}
#endif




// Review - 1 (20190915)
// 이차원 배열과 연산
#if 0
#include <stdio.h>
#define MAX     (201)
#define C_MAX	(101)

typedef struct
{
	int num;
	int cnt;
}NODE;
NODE check[C_MAX];              //

void Input(void);
void Init_Check(int m);
void Sort(int max, int i, char p);
void Operation(void);
void Print(void);

int A[MAX][MAX];
int R, C, K;
int count;
int Max_no;
int row, col;

int main(void)
{
	//freopen("in.txt", "r", stdin);
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d %d %d", &R, &C, &K);
	for (i = 1; i <= 3; i++)
	{
		for (j = 1; j <= 3; j++)
		{
			scanf("%d", &A[i][j]);
		}
	}
	Init_Check(100);
}

void Init_Check(int m)
{
	int i;

	for (i = 0; i <= m; i++)
	{
		check[i].num = i;
		check[i].cnt = 0;
	}
}

void Operation(void)
{
	int i, j;
	int max;					// A[i][j] 값 중 가장 큰 값을 구해주기 위함..!! (정렬에 필요!)
	row = 3;	col = 3;		// 첫 A는 무조건 3 * 3
	Max_no = 0;					// R연산시에는 열만, C연산시에는 행만 늘어남! 그것의 max를 구해주기 위함!

	count = 0;
	while (A[R][C] != K)
	{
		Max_no = 0;

		max = 0;
		// R연산
		if (row >= col)
		{
			for (i = 1; i <= row; i++)
			{
				for (j = 1; j <= col; j++)
				{
					check[A[i][j]].cnt++;
					if (max < A[i][j]) max = A[i][j];
				}
				for (j = 1; j <= col; j++) A[i][j] = 0;	// 연산 후 A[i][j]의 빈 곳을 0으로 채워줘야 하는데 미리 해줌
				Sort(max, i, 'R');
				Init_Check(max);
			}
			col = Max_no;
		}
		// C연산
		else
		{
			for (j = 1; j <= col; j++)
			{
				for (i = 1; i <= row; i++)
				{
					check[A[i][j]].cnt++;
					if (max < A[i][j]) max = A[i][j];
				}
				for (i = 1; i <= row; i++) A[i][j] = 0;
				Sort(max, j, 'C');
				Init_Check(max);
			}
			row = Max_no;
		}
		count++;

		if (count > 100)
		{
			count = -1;
			break;
		}
	}
}

void Sort(int max, int i, char p)
{
	int r, c, k;
	int cnt = 0;
	NODE tmp = { 0 };

	for (r = 1; r < max; r++)
	{
		for (c = r + 1; c <= max; c++)
		{
			if ((check[r].cnt > check[c].cnt) ||
				((check[r].cnt == check[c].cnt) && (check[r].num > check[c].num)))
			{
				tmp = check[r];
				check[r] = check[c];
				check[c] = tmp;
			}
		}
	}

	if (p == 'R')
	{
		for (k = 1; k <= 100; k++)
		{
			if (check[k].cnt == 0) continue;
			cnt++;
			A[i][2 * cnt - 1] = check[k].num;
			A[i][2 * cnt] = check[k].cnt;
		}
	}
	else
	{
		for (k = 1; k <= 100; k++)
		{
			if (check[k].cnt == 0) continue;
			cnt++;
			A[2 * cnt - 1][i] = check[k].num;
			A[2 * cnt][i] = check[k].cnt;
		}
	}

	if (Max_no < 2 * cnt) Max_no = 2 * cnt;
}

void Print(void)
{
	printf("%d\n", count);
}
#endif


// Review - 2 (20190915)
// 연구소 3 : 토마토와 비슷!!
#if 0
#include <stdio.h>
#define MAX     (52)

typedef struct
{
	int y, x;
}NODE;
NODE Virus[MAX * MAX];
NODE List[11];
NODE Q[MAX * MAX * 10];

void Input(void);
void InQ(int yy, int xx);
NODE * OutQ(void);
void Make_Combination(int L, int s_idx);
int BFS(void);
void Print(void);
void Init_Visit(void);

int N, M;
int Lab[MAX][MAX];
int Wp, Rp;
int Visit[MAX][MAX];    // 초기화 필요!!!
int virus_no;
int Min_Time;
int chk_0;
int chk_2;
int Min_Time_tmp;
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

int main(void)
{
	Input();
	if (chk_0 == 0)
	{
		printf("%d\n", chk_0);
		return 0;
	}
	Make_Combination(1, 1);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	Min_Time = 987654321;
	virus_no = 1;
	scanf("%d %d", &N, &M);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &Lab[i][j]);
			if (Lab[i][j] == 0) chk_0++;     // 애초에 주어지는 0이 없다면, 퍼뜨리는데 0의 시간이 걸릴 것이므로 미리 판단
			else if (Lab[i][j] == 1) Lab[i][j] = 3;  // 벽 => 0, 1, 2가 주어질테데, 2가 만약 비활성이라면 0처럼 처리해주어야 함! 그래서 조건을 쉽게 주기 위해 나중에 3으로 바꿈<1>
			else if (Lab[i][j] == 2)
			{
				Virus[virus_no].y = i;
				Virus[virus_no++].x = j;
				//printf("virus_no = %d\n", virus_no);
				chk_2++;                // 처음에 주어지는 바이러들의 위치를 일단 저장! => 이 중에서 M개를 돌아가면서 선택적으로 큐에 넣을 것임!
			}
		}
	}
}

void InQ(int yy, int xx)
{
	Q[Wp].y = yy;
	Q[Wp++].x = xx;
}

NODE * OutQ(void)
{
	return &(Q[Rp++]);
}

int BFS(void)
{
	NODE * out = (NODE *)0x0;
	int i;
	int ny, nx;
	int sy, sx;
	int check;
	int chk = chk_0 + chk_2 - M;    // 바이러스를 퍼트릴 수 있는 공간(즉, 0으로 생각해줘야 함!)
	int max = 0;

	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;
		sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];
			nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > N) continue;
			check = Visit[sy][sx] + 1;
			if ((Lab[ny][nx] <= 2) && (Visit[ny][nx] > check))     // 앞의 조건은 <1>에 의해서!
			{                                                       // Visit 배열은 최소값 갱신을 위해!
				InQ(ny, nx);
				Visit[ny][nx] = check;
				if ((Lab[ny][nx] == 0) && (max < check))       // ★ 어차피 2가 비활성이라도(퍼지지는 않지만), 이미 바이러스에 감염이 된 상태이므로 고려 X ★
				{
					max = check;
				}
				if (--chk == 0) return max;              // chk가 0이 되었다는 것은 다 감염이 되었다는 뜻!! 바로 리턴
			}
		}
	}

	return 987654320;       // 하지만 chk가 0이 되지 않고 Wp==Rp가 되었다는 것은 더 이상 감염을 시키지 못 한다는 의미이므로 일단 엄청 큰 값을 리턴. 나중에 Min 값을 판단해 줄 것인데, 여기에서도 다른 작은 수로 걸리지지 않는다면 -1리턴!
}

// DFS와 DFS를 함께!
void Make_Combination(int L, int s_idx)
{
	int i, j;//, k, l;

	if (L > M)
	{
		//for(k = 1; k < L; k++)
		//{
		//        printf("%d,%d   ", List[k].y, List[k].x);
		//}
		//printf("\n");
		Init_Visit();
		Wp = Rp = 0;
		for (j = 1; j < L; j++)
		{
			InQ(List[j].y, List[j].x);
			Visit[List[j].y][List[j].x] = 0;
		}
		Min_Time_tmp = BFS();
		//printf("Min_Time_tmp = %d\n", Min_Time_tmp);
		//for(k = 1; k <= N; k++)
		//{
		//        for(l = 1; l <= N; l++)
		//        {
		//                printf("%10d", Visit[k][l]);
		//        }
		//        printf("\n");
		//}
		//printf("\n");
		if (Min_Time > Min_Time_tmp) Min_Time = Min_Time_tmp;
		return;
	}

	for (i = s_idx; i < virus_no - M + L; i++)
	{
		List[L].y = Virus[i].y;
		List[L].x = Virus[i].x;

		Make_Combination(L + 1, i + 1);

		List[L].y = 0;
		List[L].x = 0;
	}
}

void Init_Visit(void)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			Visit[i][j] = 987654321;
		}
	}
}

void Print(void)
{
	if (Min_Time == 987654320) printf("-1\n");
	else printf("%d\n", Min_Time);
}
#endif




// Review - 3 (20190915)
// 이렇게 제출했음;;; 근데 틀림 ㅋㅋ
#if 0
#include <stdio.h>
#define MAX     (1000)

void Input(void);
void Init(void);
void Make_Comb(void);
void DFS(int L, int click, int result);
void Print_List(int L);
void Print_Comb(void);
//void Print(void);

int T;
int N, O, M, W;
int num[MAX];
int comb[MAX];
int comb_no;
int oper[5];
int flag;
int List[20];

void Init(void)
{
	int i;

	comb_no = 1;
	for (i = 0; i < MAX; i++)
	{
		num[i] = 21;
	}
	for (i = 0; i < 5; i++)
	{
		oper[i] = 0;
	}
}

void Input(void)
{
	int i, tmp;

	scanf("%d %d %d", &N, &O, &M);
	for (i = 1; i <= N; i++)
	{
		scanf("%d", &tmp);
		num[tmp] = 1;
		comb[comb_no++] = tmp;
	}
	for (i = 1; i <= O; i++)
	{
		scanf("%d", &tmp);
		oper[tmp] = 1;
	}
	scanf("%d", &W);
}

// 연산 X && 한 번의 클릭으로 만들 수 있는 한 자리수는 이미 있으므로,
// 두 번의 클릭으로 만들 수 있는 두 자리 수와 세 번의 클릭으로 만들 수 있는 세자리수를 세팅해줌! (연산이 들어가는 순간 적어도 4번의 클릭 필요! 하지만 여기까지는 1 ~ 3번의 클릭만 필요!)
void Make_Comb(void)
{
	int i, j, k;
	int tmp = 0;
	flag = 0;

	// 두자리수 만듬 only by 2 clicks
	for (i = 1; i <= 9; i++)
	{
		if (num[i] == 1)
		{
			tmp = i * 10;
			for (j = 0; j <= 9; j++)
			{
				if (num[j] == 1)
				{
					tmp += j;
					comb[comb_no++] = tmp;
					num[tmp] = 2;
					tmp -= j;
				}
			}
			tmp = 0;
		}
	}

	// 세 자리수 만듬 only by 3 clicks
	for (i = 1; i <= 9; i++)
	{
		if (num[i] == 1)
		{
			tmp = i * 100;
			for (j = 0; j <= 9; j++)
			{
				if (num[j] == 1)
				{
					tmp += j * 10;
					for (k = 0; k <= 9; k++)
					{
						if (num[k] == 1)
						{
							tmp += k;
							comb[comb_no++] = tmp;
							num[tmp] = 3;
							tmp -= k;
						}
					}
					tmp -= j * 10;
				}
			}
			tmp = 0;
		}
	}

	for (i = 0; i < MAX; i++)
	{
		if (num[W] < 21) flag = 1;
	}
}

void DFS(int L, int click, int result)
{
	int i, j, prev;

	if (click > num[W]) return;
	if (click > M) return;
	//printf("L = %d, click = %d, result = %d\n", L, click, result);
	if (result == W)
	{
		if (num[W] > click) num[W] = click;
		//Print_List(L);
		return;
	}

	for (i = 1; i < comb_no; i++)
	{
		List[L] = comb[i];
		prev = result;
		for (j = 1; j <= 4; j++)
		{
			if (oper[j] != 1) continue;
			switch (j)
			{
			case 1:
				result += List[L];
				break;
			case 2:
				result -= List[L];
				break;
			case 3:
				result *= List[L];
				break;
			default:
				if (List[L] == 0) continue;
				result /= List[L];
				break;
			}
			if (result < 0 || result > 999)
			{
				result = prev;
				continue;
			}
			DFS(L + 1, click + num[List[L]] + 1, result);
			result = prev;
		}
		List[L] = 0;
	}

}

void Print_Comb(void)
{
	int i;

	for (i = 1; i < comb_no; i++)
	{
		printf("%d ", comb[i]);
	}
	printf("\n");
}


void Print_List(int L)
{
	int i;

	for (i = 1; i < L; i++)
	{
		printf("%d ", List[i]);
	}
	printf("\n");
}

/*
void Print(void)
{
printf("#%d ", T);
if(num[W] == 21) printf("-1\n");
else printf("%d\n", num[W]);
}
*/

/////////////////////////////////////////////////////////////////////////////////////////////
// 기본 제공코드는 임의 수정해도 관계 없습니다. 단, 입출력 포맷 주의
// 아래 표준 입출력 예제 필요시 참고하세요.
// 표준 입력 예제
// int a;
// float b, c;
// double d, e, f;
// char g;
// char var[256];
// long long AB;
// scanf("%d", &a);                      // int 변수 1개 입력받는 예제
// scanf("%f %f", &b, &c);               // float 변수 2개 입력받는 예제
// scanf("%lf %lf %lf", &d, &e, &f);     // double 변수 3개 입력받는 예제
// scanf("%c", &g);                      // char 변수 1개 입력받는 예제
// scanf("%s", &var);                    // 문자열 1개 입력받는 예제
// scanf("%lld", &AB);                   // long long 변수 1개 입력받는 예제
/////////////////////////////////////////////////////////////////////////////////////////////
// 표준 출력 예제
// int a = 0;
// float b = 1.0, c = 2.0;
// double d = 3.0, e = 0.0; f = 1.0;
// char g = 'b';
// char var[256] = "ABCDEFG";
// long long AB = 12345678901234567L;
// printf("%d", a);                      // int 변수 1개 출력하는 예제
// printf("%f %f", b, c);                // float 변수 2개 출력하는 예제
// printf("%lf %lf %lf", d, e, f);       // double 변수 3개 출력하는 예제
// printf("%c", g);                      // char 변수 1개 출력하는 예제
// printf("%s", var);                    // 문자열 1개 출력하는 예제
// printf("%lld", AB);                   // long long 변수 1개 출력하는 예제
/////////////////////////////////////////////////////////////////////////////////////////////
int main(void)
{
	int test_case, j;
	int T;
	/* 아래의 freopen 함수는 input.txt 를 read only 형식으로 연 후,
	앞으로 표준 입력(키보드) 대신 input.txt 파일로부터 읽어오겠다는 의미의 코드입니다.
	여러분이 작성한 코드를 테스트 할 때, 편의를 위해서 input.txt에 입력을 저장한 후,
	freopen 함수를 이용하면 이후 scanf 를 수행할 때 표준 입력 대신 파일로부터 입력을 받아올 수 있습니다.
	따라서 테스트를 수행할 때에는 아래 주석을 지우고 이 함수를 사용하셔도 좋습니다.
	단, 채점을 위해 코드를 제출하실 때에는 반드시 freopen 함수를 지우거나 주석 처리 하셔야 합니다.
	*/
	// freopen("input.txt", "r", stdin);
	/* 아래 코드를 수행하지 않으면 여러분의 프로그램이 제한 시간 초과로 강제 종료 되었을 때,
	출력한 내용이 실제 표준 출력에 기록되지 않을 수 있습니다.
	따라서 안전을 위해 반드시 setbuf(stdout, NULL); 을 수행하시기 바랍니다.
	*/
	setbuf(stdout, NULL);
	scanf("%d", &T);
	/*
	여러 개의 테스트 케이스를 처리하기 위한 부분입니다.
	*/
	for (test_case = 1; test_case <= T; ++test_case)
	{
		Init();
		Input();
		Make_Comb();
		//Print_Comb();
		if (flag)
		{
			printf("%d\n", num[W]);
			continue;
		}
		for (j = 1; j < comb_no; j++)
		{
			List[1] = comb[j];
			//printf("[in main] L = %d, click = %d, result = %d\n", 2, num[j], comb[j]);
			DFS(2, num[comb[j]] + 1, comb[j]);
			List[1] = 0;
		}
		printf("#%d ", test_case);
		if (num[W] == 21) printf("-1\n");
		else printf("%d\n", num[W]);
	}
	return 0; //정상종료시 반드시 0을 리턴해야 합니다.
}
#endif


// 다시 풀어봐야 함..!!
// 4311. [연습문제] 오래된 스마트폰
// =>BFS로 다시 풀어봐야지!! (20190915) => 미완ㅋ
#if 0
#include <stdio.h>
#define MAX (1100)

void Input(void);
void Init_Click(void);
void Make_Num_Click(void);
int Choose_One(int a, int b, int oper);
int BFS(void);

int T;
int N, O, M, W;
int click[MAX];
int oper[5];
int flag;
int Q[MAX * MAX * 10];
int Wp, Rp;
int Input_Num[MAX];
int order;
int Zero_Flag;

int main(void)
{
	int test_case, r;
	/* 아래의 freopen 함수는 input.txt 를 read only 형식으로 연 후,
	앞으로 표준 입력(키보드) 대신 input.txt 파일로부터 읽어오겠다는 의미의 코드입니다.
	여러분이 작성한 코드를 테스트 할 때, 편의를 위해서 input.txt에 입력을 저장한 후,
	freopen 함수를 이용하면 이후 scanf 를 수행할 때 표준 입력 대신 파일로부터 입력을 받아올 수 있습니다.
	따라서 테스트를 수행할 때에는 아래 주석을 지우고 이 함수를 사용하셔도 좋습니다.
	단, 채점을 위해 코드를 제출하실 때에는 반드시 freopen 함수를 지우거나 주석 처리 하셔야 합니다.
	*/
	// freopen("input.txt", "r", stdin);
	/* 아래 코드를 수행하지 않으면 여러분의 프로그램이 제한 시간 초과로 강제 종료 되었을 때,
	출력한 내용이 실제 표준 출력에 기록되지 않을 수 있습니다.
	따라서 안전을 위해 반드시 setbuf(stdout, NULL); 을 수행하시기 바랍니다.
	*/
	setbuf(stdout, NULL);
	scanf("%d", &T);
	/*
	여러 개의 테스트 케이스를 처리하기 위한 부분입니다.
	*/
	for (test_case = 1; test_case <= T; ++test_case)
	{
		Init_Click();
		Input();
		Make_Num_Click();
		if (flag)
		{
			printf("#%d %d\n", T, click[W]);
		}
		else
		{
			r = BFS();
			r++;
			printf("#%d %d\n", T, ((r <= M) ? r : -1));
		}
	}

	return 0;
}

void Init_Click(void)
{
	int i;

	order = 0;
	flag = 0;
	Zero_Flag = 0;
	for (i = 0; i < MAX; i++)
	{
		click[i] = 21;
	}
	for (i = 0; i < 5; i++)
	{
		oper[i] = 0;
	}
}

void Input(void)
{
	int i, tmp;
	int ttmp;

	scanf("%d %d %d", &N, &O, &M);
	for (i = 0; i < N; i++)
	{
		scanf("%d", &tmp);
		click[tmp] = 1;
		Input_Num[order++] = tmp;
		if (tmp == 0)
		{
			ttmp = Input_Num[0];
			Input_Num[0] = tmp;
			Input_Num[order - 1] = ttmp;
			Zero_Flag = 1;
		}
	}
	for (i = 1; i <= O; i++)
	{
		scanf("%d", &oper[i]);
	}
	scanf("%d", &W);

	/*for (i = 1; i < N; i++)
	{
		printf("%d ", Input_Num[i]);
	}*/
}

void Make_Num_Click(void)
{
	int i, j, k;
	int tmp;

	// 두 자리수 만들기 by only 2 clicks
	for (i = Zero_Flag; i < N; i++)
	{
		tmp = Input_Num[i] * 10;
		for (j = 0; j < N; j++)
		{
			tmp += Input_Num[j];
			click[tmp] = 2;
			Input_Num[order++] = tmp;
			tmp -= Input_Num[j];
		}
		tmp = 0;
	}

	// 세 자리수 만들기 by only 3 clicks
	for (i = Zero_Flag; i < N; i++)
	{
		tmp = Input_Num[i] * 100;
		for (j = 0; j < N; j++)
		{
			tmp += Input_Num[j] * 10;
			for (k = 0; k < N; k++)
			{
				tmp += Input_Num[k];
				click[tmp] = 3;
				Input_Num[order++] = tmp;
				tmp -= Input_Num[k];
			}
			tmp -= Input_Num[j] * 10;
		}
		tmp = 0;
	}

	if (click[W] <= M) flag = 1;
}

int BFS(void)
{
	int i, j, check;
	int r;
	int out;
	Wp = Rp = 0;

	for (i = Zero_Flag; i < order; i++)
	{
		Q[Wp++] = Input_Num[i];
	}

	while (Wp > Rp)
	{
		//printf("click[W] = %d\n", click[W]);
		//printf("Wp = %d, Rp = %d\n", Wp, Rp);
		out = Q[Rp++];
		//if (out == 0) continue;
		for (j = 1; j <= O; j++)
		{
			for (i = Zero_Flag; i < order; i++)
			{
				r = Choose_One(out, Input_Num[i], oper[j]);
				if (r < 0 || r > 999) continue;
				check = click[ Input_Num[i] ] + click[out] + 1;
				if (check >= M) continue;
				if (click[r] > check)
				{
					click[r] = check;
					Q[Wp++] = r;
				}
			}
		}
	}

	/*printf("\n\n");
	for (i = 1; i <= 999; i++)
	{
		printf("%d ", click[i]);
	}
	printf("\n\n");*/

	return click[W];
}

int Choose_One(int a, int b, int op)
{
	switch (op)
	{
		case 1: return a + b;
		case 2: return a - b;
		case 3: return a * b;
		default:
			//if (b == 0) return 1000;
			return a / b;
	}
}
#endif
// => 다 품 (테스트케이스 변수 조심..!!)
#if 0
#include <stdio.h>
#define MAX (1100)

void Input(void);
void Init_Click(void);
void Make_Num_Click(void);
int Choose_One(int a, int b, int oper);
int BFS(void);

int T;
int N, O, M, W;
int click[MAX];
int oper[5];
int Q[MAX * MAX];
int Wp, Rp;
int Input_Num[MAX];
int order;
int Zero_Flag, flag;

int main(void)
{
	int test_case, r;
	O = 4;
	setbuf(stdout, NULL);
	scanf("%d", &T);

	for (test_case = 1; test_case <= T; ++test_case)
	{
		Init_Click();
		Input();
		Make_Num_Click();
		if (flag)
		{
			printf("#%d %d\n", test_case, click[W]);
		}
		else
		{
			r = BFS();
			printf("#%d %d\n", test_case, ((r++ <= M) ? r : -1));
		}
	}

	return 0;
}

void Init_Click(void)
{
	int i;

	order = 0;	flag = 0;	Zero_Flag = 0;
	for (i = 0; i <= MAX; i++) click[i] = 21;
	for (i = 0; i <= O; i++) oper[i] = 0;
}

void Input(void)
{
	int i, tmp, ttmp;

	scanf("%d %d %d", &N, &O, &M);
	for (i = 0; i < N; i++)
	{
		scanf("%d", &tmp);
		click[tmp] = 1;
		Input_Num[order++] = tmp;
	}
	for (i = 0; i < N; i++)
	{
		if (Input_Num[i] == 0)
		{
			tmp = Input_Num[0];
			Input_Num[0] = Input_Num[i];
			Input_Num[i] = tmp;
			Zero_Flag = 1;
			break;
		}
	}
	for (i = 1; i <= O; i++) scanf("%d", &oper[i]);
	scanf("%d", &W);
}

void Make_Num_Click(void)
{
	int i, j, k;
	int tmp;

	// 두 자리수 만들기 by only 2 clicks
	for (i = Zero_Flag; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			tmp = Input_Num[i] * 10 + Input_Num[j];
			click[tmp] = 2;
			Input_Num[order++] = tmp;
		}
	}
	// 세 자리수 만들기 by only 3 clicks
	for (i = Zero_Flag; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			for (k = 0; k < N; k++)
			{
				tmp = Input_Num[i] * 100 + Input_Num[j] * 10 + Input_Num[k];
				click[tmp] = 3;
				Input_Num[order++] = tmp;
			}
		}
	}
	if (click[W] <= M) flag = 1;
}

int BFS(void)
{
	int i, j, check;
	int r, out, target;
	Wp = Rp = 0;

	for (i = Zero_Flag; i < order; i++) Q[Wp++] = Input_Num[i];

	while (Wp > Rp)
	{
		out = Q[Rp++];
		for (i = Zero_Flag; i < order; i++)
		{
			target = Input_Num[i];
			for (j = 1; j <= O; j++)
			{
				r = Choose_One(out, target, oper[j]);
				if (r <= 0 || r > 999) continue;
				check = click[target] + click[out] + 1;
				if (check >= M) continue;
				if (click[r] > check)
				{
					click[r] = check;
					Q[Wp++] = r;
				}
			}
		}
	}
	return click[W];
}

int Choose_One(int a, int b, int op)
{
	switch (op)
	{
	case 1: return a + b;
	case 2: return a - b;
	case 3: return a * b;
	default: return a / b;
	}
}
#endif

// => DFS로도 다시 풀어보자!
#if 0
#include <stdio.h>
#define MAX (1100)
#define NAX (25)
enum OPERATE { NOTHING, PLUS, MINUS, MULT, DIV };

void Init(void);
void Input(void);
void Make_Num_Comb(void);
void DFS(int L, int result);
int Get_Result(int a, int b, int op);
void Print(void);

int T;
int N, O, M, W;
int click[MAX];
int oper[5];
int List[NAX];
int Make_Num[MAX];
int Zero_Flag;
int flag;
int no;
int Min_Touch;


int main(void)
{
	int i, j;

	setbuf(stdout, NULL);
	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Init();
		Input();
		Make_Num_Comb();
		if (flag)
		{
			printf("#%d %d\n", i, click[W]);
			continue;
		}
		
		printf("#%d ", i);
		Print();
	}


	return 0;
}

void Init(void)
{
	int i;

	flag = 0;
	Zero_Flag = 0;
	Min_Touch = 21;
	for (i = 0; i <= 999; i++) click[i] = 21;
	for (i = 0; i < 5; i++) oper[i] = 0;
}

void Input(void)
{
	int i, tmp;

	scanf("%d %d %d", &N, &O, &M);
	for (i = 0; i < N; i++)
	{
		scanf("%d", &Make_Num[i]);
		click[Make_Num[i]] = 1;
	}
	for (i = 0; i < N; i++)
	{
		if (Make_Num[i] == 0)
		{
			tmp = Make_Num[0];
			Make_Num[0] = Make_Num[i];
			Make_Num[i] = tmp;
			break;
		}
	}
	for (i = 1; i <= O; i++)
	{
		scanf("%d", &oper[i]);
	}
	scanf("%d", &W);
}

void Make_Num_Comb(void)
{
	int i, j, k, tmp;

	no = N;
	for (i = Zero_Flag; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			tmp = Make_Num[i] * 10 + Make_Num[j];
			Make_Num[no++] = tmp;
			click[tmp] = 2;
		}
	}

	for (i = Zero_Flag; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			for (k = 0; k < N; k++)
			{
				tmp = Make_Num[i] * 100 + Make_Num[j] * 10 + Make_Num[k];
				Make_Num[no++] = tmp;
				click[tmp] = 3;
			}
		}
	}

	if (click[W] <= M) flag = 1;
}

void DFS(int L, int result)
{
	int i, j, r;

	if (result == W)
	{
		if (Min_Touch > click[W]) Min_Touch = click[W];
		return;
	}

	for (i = Zero_Flag; i < N; i++)
	{
		for (j = 1; j <= O; j++)
		{
			r = Get_Result(result, Make_Num[i], oper[j]);
			if (r <= 0 || r > 999) continue;

			DFS(L + 1, r);

		}
	}

}

int Get_Result(int a, int b,int op)
{
	switch (op)
	{
		case PLUS: return a + b;
		case MINUS: return a - b;
		case MULT: return a * b;
		default: return a / b;
	}
}

void Print(void)
{
	Min_Touch++;
	printf("%d\n", ((Min_Touch <= M) ? Min_Touch : -1));
}
#endif




// 20190915 13:17부터 시작!!!
// 설계 : 약 30분 걸림(그런데 조급해져서 일단 코드 짜보기로 함!)
// 코드 :
// 디버그 :
// 2048 (easy)
#if 0
#include <stdio.h>
#define MAX     (25)

typedef struct
{
	int arr[MAX][MAX];
}NODE;
NODE List[7];

void Input(void);
void DFS(int L);
void Copy_Arr(int L);
void Clear_Arr(int L);
int Same_Check(int L);
void Make_Board(int dir);
void Left(void);
void Right(void);
void Up(void);
void Down(void);
void Get_Max_Block(void);
void Print(void);
void(*func[5])(void) = { 0, Left, Right, Up, Down };

int N;          // 보드의 크기
int Board[MAX][MAX];
int Max_Block;
int cnt;

int main(void)
{
	Input();
	DFS(1);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	Max_Block = 0;
	scanf("%d", &N);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &Board[i][j]);
			if (Max_Block < Board[i][j]) Max_Block = Board[i][j];
		}
	}
}

void DFS(int L)
{
	int i;

	//printf("[%d] L = %d\n", ++cnt, L);

	if (L > 5 || Same_Check(L - 1))
	{
		return;
	}

	for (i = 1; i <= 4; i++)
	{
		Copy_Arr(L);
		Make_Board(i);
		DFS(L + 1);
		Clear_Arr(L);
	}
}

void Copy_Arr(int L)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			List[L].arr[i][j] = Board[i][j];
		}
	}
}

void Clear_Arr(int L)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			Board[i][j] = List[L].arr[i][j];
			List[L].arr[i][j] = 0;
		}
	}
}

int Same_Check(int L)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			if (List[L].arr[i][j] != Board[i][j]) return 0;
		}
	}

	return 1;
}

void Make_Board(int dir)
{
	func[dir]();

	Get_Max_Block();
}

void Left(void)
{
	int i, j;
	int n, no;
	int tmp[MAX] = { 0 };

	for (i = 1; i <= N; i++)
	{
		no = 1;         n = 1;
		for (j = 1; j <= N; j++) tmp[j] = 0;
		for (j = 1; j <= N; j++)
		{
			if (Board[i][j] == 0) continue;
			tmp[no++] = Board[i][j];
		}
		for (j = 1; j < no; j++)
		{
			if (tmp[j] == tmp[j + 1])
			{
				tmp[j] *= 2;
				Board[i][n++] = tmp[j];
				tmp[j + 1] = 0;
				j++;
			}
			else Board[i][n++] = tmp[j];
		}
		for (j = n; j <= N; j++)
		{
			Board[i][j] = 0;
		}
	}
}

void Right(void)
{
	int i, j;
	int n, no;
	int tmp[MAX] = { 0 };

	for (i = 1; i <= N; i++)
	{
		no = N;         n = N;
		for (j = 1; j <= N; j++) tmp[j] = 0;
		for (j = N; j >= 1; j--)
		{
			if (Board[i][j] == 0) continue;
			tmp[no--] = Board[i][j];
		}
		for (j = N; j > no; j--)
		{
			if (tmp[j] == tmp[j - 1])
			{
				tmp[j] *= 2;
				Board[i][n--] = tmp[j];
				tmp[j - 1] = 0;
				j--;
			}
			else Board[i][n--] = tmp[j];
		}
		for (j = 1; j <= n; j++)
		{
			Board[i][j] = 0;
		}
	}
}

void Up(void)
{
	int i, j;
	int n, no;
	int tmp[MAX] = { 0 };

	for (j = 1; j <= N; j++)
	{
		no = 1;         n = 1;
		for (i = 1; i <= N; i++) tmp[i] = 0;
		for (i = 1; i <= N; i++)
		{
			if (Board[i][j] == 0) continue;
			tmp[no++] = Board[i][j];
		}
		for (i = 1; i < no; i++)
		{
			if (tmp[i] == tmp[i + 1])
			{
				tmp[i] *= 2;
				Board[n++][j] = tmp[i];
				tmp[i + 1] = 0;
				i++;
			}
			else Board[n++][j] = tmp[i];
		}
		for (i = n; i <= N; i++)
		{
			Board[i][j] = 0;
		}
	}
}

void Down(void)
{
	int i, j;
	int n, no;
	int tmp[MAX] = { 0 };

	for (j = 1; j <= N; j++)
	{
		no = N;         n = N;
		for (i = 1; i <= N; i++) tmp[i] = 0;
		for (i = N; i >= 1; i--)
		{
			if (Board[i][j] == 0) continue;
			tmp[no--] = Board[i][j];
		}
		for (i = N; i > no; i--)
		{
			if (tmp[i] == tmp[i - 1])
			{
				tmp[i] *= 2;
				Board[n--][j] = tmp[i];
				tmp[i - 1] = 0;
				i--;
			}
			else Board[n--][j] = tmp[i];
		}
		for (i = 1; i <= n; i++)
		{
			Board[i][j] = 0;
		}
	}
}

void Get_Max_Block(void)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			if (Board[i][j] > Max_Block) Max_Block = Board[i][j];
		}
	}
}

void Print(void)
{
	printf("%d\n", Max_Block);
}
#endif


// 2048 (hard)
#if 0
#include <stdio.h>
#define MAX     (25)

typedef struct
{
	int arr[MAX][MAX];
	int max;
}NODE;
NODE List[15];

void Input(void);
void DFS(int L);
void Copy_Arr(int L);
void Clear_Arr(int L);
int Same_Check(int L);
void Make_Board(int dir, int L);
void Left(void);
void Right(void);
void Up(void);
void Down(void);
void Get_Max_Block(int L);
void Print(void);
//void (*func[5])(void) = { 0, Left, Right, Up, Down };

int N;          // 보드의 크기
int Board[MAX][MAX];
int Max_Block;
int cnt;

int main(void)
{
	Input();
	DFS(1);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	List[0].max = 543210;
	Max_Block = 0;
	scanf("%d", &N);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &Board[i][j]);
			if (Max_Block < Board[i][j]) Max_Block = Board[i][j];
		}
	}
}

void DFS(int L)
{
	int i;
	int Power_2[11] = { 0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024 };

	printf("[%d] L = %d\n", ++cnt, L);


	if ( List[L - 1].max * Power_2[11 - L] <= Max_Block ) return;
	if ( L > 10 || Same_Check(L - 1) )
	{
		return;
	}

	for (i = 1; i <= 4; i++)
	{
		Copy_Arr(L);
		Make_Board(i, L);
		DFS(L + 1);
		Clear_Arr(L);
	}
}

void Copy_Arr(int L)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			List[L].arr[i][j] = Board[i][j];
		}
	}
}

void Clear_Arr(int L)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			Board[i][j] = List[L].arr[i][j];
			List[L].arr[i][j] = 0;
			List[L].max = 0;
		}
	}
}

int Same_Check(int L)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			if (List[L].arr[i][j] != Board[i][j]) return 0;
		}
	}

	return 1;
}

void Make_Board(int dir, int L)
{
	//int i, j;

	switch (dir)
	{
		// 좌
		case 1:
			Left();
			break;
		// 우
		case 2:
			Right();
			break;
		// 상
		case 3:
			Up();
			break;
		// 하
		default:
			Down();
			break;
	}

	//func[dir]();

	Get_Max_Block(L);

	/*printf("\n");
	for(i = 1; i <= N; i++)
	{
	for(j = 1; j <= N; j++)
	{
	printf("%d ", Board[i][j]);
	}
	printf("\n");
	}
	printf("\n");*/
}

void Left(void)
{
	int i, j;
	int n, no;
	int tmp[MAX] = { 0 };

	for (i = 1; i <= N; i++)
	{
		no = 1;         n = 1;
		for (j = 1; j <= N; j++) tmp[j] = 0;
		for (j = 1; j <= N; j++)
		{
			if (Board[i][j] == 0) continue;
			tmp[no++] = Board[i][j];
		}
		for (j = 1; j < no; j++)
		{
			if (tmp[j] == tmp[j + 1])
			{
				tmp[j] *= 2;
				Board[i][n++] = tmp[j];
				tmp[j + 1] = 0;
				j++;
			}
			else Board[i][n++] = tmp[j];
		}
		for (j = n; j <= N; j++)
		{
			Board[i][j] = 0;
		}
	}
}

void Right(void)
{
	int i, j;
	int n, no;
	int tmp[MAX] = { 0 };

	for (i = 1; i <= N; i++)
	{
		no = N;         n = N;
		for (j = 1; j <= N; j++) tmp[j] = 0;
		for (j = N; j >= 1; j--)
		{
			if (Board[i][j] == 0) continue;
			tmp[no--] = Board[i][j];
		}
		for (j = N; j > no; j--)
		{
			if (tmp[j] == tmp[j - 1])
			{
				tmp[j] *= 2;
				Board[i][n--] = tmp[j];
				tmp[j - 1] = 0;
				j--;
			}
			else Board[i][n--] = tmp[j];
		}
		for (j = 1; j <= n; j++)
		{
			Board[i][j] = 0;
		}
	}
}

void Up(void)
{
	int i, j;
	int n, no;
	int tmp[MAX] = { 0 };

	for (j = 1; j <= N; j++)
	{
		no = 1;         n = 1;
		for (i = 1; i <= N; i++) tmp[i] = 0;
		for (i = 1; i <= N; i++)
		{
			if (Board[i][j] == 0) continue;
			tmp[no++] = Board[i][j];
		}
		for (i = 1; i < no; i++)
		{
			if (tmp[i] == tmp[i + 1])
			{
				tmp[i] *= 2;
				Board[n++][j] = tmp[i];
				tmp[i + 1] = 0;
				i++;
			}
			else Board[n++][j] = tmp[i];
		}
		for (i = n; i <= N; i++)
		{
			Board[i][j] = 0;
		}
	}
}

void Down(void)
{
	int i, j;
	int n, no;
	int tmp[MAX] = { 0 };

	for (j = 1; j <= N; j++)
	{
		no = N;         n = N;
		for (i = 1; i <= N; i++) tmp[i] = 0;
		for (i = N; i >= 1; i--)
		{
			if (Board[i][j] == 0) continue;
			tmp[no--] = Board[i][j];
		}
		for (i = N; i > no; i--)
		{
			if (tmp[i] == tmp[i - 1])
			{
				tmp[i] *= 2;
				Board[n--][j] = tmp[i];
				tmp[i - 1] = 0;
				i--;
			}
			else Board[n--][j] = tmp[i];
		}
		for (i = 1; i <= n; i++)
		{
			Board[i][j] = 0;
		}
	}
}

void Get_Max_Block(int L)
{
	int i, j, max = 0;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			if (Board[i][j] > Max_Block) Max_Block = Board[i][j];
			if (Board[i][j] > max) max = Board[i][j];
		}
	}
	List[L].max = max;
}

void Print(void)
{
	printf("%d\n", Max_Block);
}
#endif





// 20190915
// 주사위 굴리기
#if 0
#include <stdio.h>
#define MAX     (25)
#define CAX     (1001)

typedef struct
{
	int up;            // 1
	int behind;        // 2
	int right;         // 3
	int left;          // 4
	int front;         // 5
	int down;          // 6
}CUBE;
CUBE Dice;

typedef struct
{
	int yy, xx;
}NODE;
NODE Location;

void Input(void);
void Operation(void);

int N, M;
int Map[MAX][MAX];
int x, y;
int K;
int Command[CAX];
int dy[5] = { 0, 0, 0, -1, 1 };
int dx[5] = { 0, 1, -1, 0, 0 };

int main(void)
{
	Input();
	Operation();

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d %d %d %d %d", &N, &M, &x, &y, &K);
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < M; j++)
		{
			scanf("%d", &Map[i][j]);
		}
	}
	for (i = 1; i <= K; i++)
	{
		scanf("%d", &Command[i]);
	}
}

void Operation(void)
{
	int i;
	int ny, nx;
	int tmp;
	Dice.up = Dice.behind = Dice.left = Dice.right = Dice.front = Dice.down = 0;
	Location.yy = x;        Location.xx = y;

	for (i = 1; i <= K; i++)
	{
		ny = Location.yy + dy[Command[i]];
		nx = Location.xx + dx[Command[i]];
		if (ny < 0 || nx < 0 || ny >= N || nx >= M) continue;

		Location.yy = ny;
		Location.xx = nx;

		switch (Command[i])
		{
		case 1:
			tmp = Dice.down;
			Dice.down = Dice.right;
			Dice.right = Dice.up;
			Dice.up = Dice.left;
			Dice.left = tmp;
			break;
		case 2:
			tmp = Dice.down;
			Dice.down = Dice.left;
			Dice.left = Dice.up;
			Dice.up = Dice.right;
			Dice.right = tmp;
			break;
		case 3:
			tmp = Dice.behind;
			Dice.behind = Dice.up;
			Dice.up = Dice.front;
			Dice.front = Dice.down;
			Dice.down = tmp;
			break;
		default:
			tmp = Dice.down;
			Dice.down = Dice.front;
			Dice.front = Dice.up;
			Dice.up = Dice.behind;
			Dice.behind = tmp;
			break;
		}

		if (Map[ny][nx] == 0)
		{
			Map[ny][nx] = Dice.down;
		}
		else
		{
			Dice.down = Map[ny][nx];
			Map[ny][nx] = 0;		// 문제 제대로 안 읽음!!
		}
		printf("%d\n", Dice.up);
	}
}
#endif



// 20190918
// 흥미로운 수열	=>	이분탐색으로 하기! (for문 너무 많이 돌아서 시간초과 뜸!)
#if 0
#include <stdio.h>
#define MAX	(100010)

void Input(void);
void Operation(void);
int Get_Result(int s, int e);

int N, K, S;
int ARR[MAX];
int Save_Result[MAX];

int main(void)
{
	Input();
	Operation();

	return 0;
}

void Input(void)
{
	int i;
	scanf("%d %d", &N, &S);
	for (i = 0; i < N; i++) scanf("%d", &ARR[i]);
}

void Operation(void)
{
	int i, j, ij;
	int sum1, sum2;
	
	for (i = 0; i < N; i++)
	{
		K = N - i;
		if (K & 1) K--;
		for (j = 0; j <= K; j += 2)
		{
			ij = i + j / 2;
			sum1 = Get_Result(i, ij);
			sum2 = Get_Result(ij, i + j);
			if (sum1 > S || sum2 > S) break;
		}
		Save_Result[i] = ((j == 0) ? 0 : j - 2);
		//printf("[%d] sum1 = %d, sum2 = %d\n", i, sum1, sum2);
		printf("%d\n", Save_Result[i]);
	}
}

int Get_Result(int s, int e)
{
	int i, sum = 0;

	for (i = s; i < e; i++) sum += ARR[i];

	return sum;
}
#endif



// 20190918
// 7830. 마름모 찾기 D5
#if 0
#include <stdio.h>
#define MAX	(760)

typedef struct
{
	int y, x;
}NODE;
NODE Q[MAX * MAX];

void Input(void);
void Init_Visit(void);
//void Init_Visit_Check(void);
void Operation(void);
void InQ(int yy, int xx);
NODE * OutQ(void);
int BFS(int sy, int sx);
void Print_Visit(void);

int T;
int N, M;
int Map[MAX][MAX];
int Visit[MAX][MAX];
int Visit_Check[MAX];
int Max;
int NM;
int Wp, Rp;
int dy[4] = { -1, -1, 1, 1 };
int dx[4] = { -1, 1, -1, 1 };
int r;

int main(void)
{
	int i;

	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Input();
		//Init_Visit_Check();
		Operation();
		printf("#%d %d\n", i, Max);
	}

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d %d", &N, &M);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			scanf("%1d", &Map[i][j]);
		}
	}

	NM = (N <= M) ? N : M;	// 행, 열 중 작은 것의 값 찾기
	if(NM & 1) NM--;
}

void InQ(int yy, int xx)
{
	Q[Wp].y = yy;
	Q[Wp++].x = xx;
}

NODE * OutQ(void)
{
	return &(Q[Rp++]);
}

void Init_Visit(void)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			Visit[i][j] = 0;
		}
	}
}

//void Init_Visit_Check(void)
//{
//	int i;
//
//	for (i = 1; i <= NM; i++) Visit_Check[i] = 0;
//}


void Operation(void)
{
	int i, j;
	
	Max = 0;
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			if (Map[i][j] == 1)
			{
				Init_Visit();
				r = BFS(i, j);
				if (Max < r) Max = r;
				Print_Visit();
			}
		}
	}
}

int BFS(int sy, int sx)
{
	NODE * out = (NODE *)0x0;
	int i;
	int ny, nx;
	int Max_Size = 0;
	int check;
	//int level = 0;

	//if (Map[sy][sx] == 1) Max_Size = 1;

	Wp = Rp = 0;
	InQ(sy, sx);
	Visit[sy][sx] = 1;
	//Visit_Check[1]++;

	printf("==================================\n");

	while (Wp > Rp)
	{
		printf("Yop!!\n");
		out = OutQ();
		sy = out->y;
		sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];
			nx = sx + dx[i];
			if ( ny < 1 || ny > N || nx < 1 || nx > M ) continue;
			if (Visit[ny][nx] == 0 && Map[ny][nx] == 1)
			{
				check = Visit[sy][sx] + 1;
				if (Visit[ny][nx] == check) Max_Size = (check + 1) / 2;
				else
				{
					InQ(ny, nx);
					Visit[ny][nx] = check;
				}
			}
			
		}
	}

	printf("Max_Size = %d\n", Max_Size);
	return Max_Size;
}

void Print_Visit(void)
{
	int i, j;

	printf("\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			printf("%d ", Visit[i][j]);
		}
		printf("\n");
	}
	printf("r = %d\n\n", r);
}
#endif



// 맑은 정신으로 다시 한 번 더 풀어보기!! (20190923에!!)
// 20190918
// 7830. 마름모 찾기 D5
#if 0
#include <stdio.h>
#define MIN(a, b)  ( ((a) <= (b)) ? (a) : (b) )
#define MAX  (760)

typedef struct
{
	int y, x;
	int direction;
}NODE;
NODE Q[MAX * MAX * 10];

void Input(void);
void Init_Visit(void);
void Operation(void);
void InQ(int yy, int xx);
NODE * OutQ(void);
int BFS(int sy, int sx);
void Print_Visit(void);

int T;
int N, M;
int Map[MAX][MAX];
int Visit[MAX][MAX];
int Max;
int Wp, Rp;
int dy[4] = { 1, 1, -1, -1 };
int dx[4] = { 1, -1, -1, 1 };
int dir;

int main(void)
{
	int i;

	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Input();
		Operation();
		printf("#%d %d\n", i, ((Max == 0) ? 1 : Max));
	}

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d %d", &N, &M);
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < M; j++)
		{
			scanf("%1d", &Map[i][j]);
		}
	}
}

void InQ(int yy, int xx, int dd)
{
	Q[Wp].y = yy;
	Q[Wp].x = xx;
	Q[Wp++].direction = dd;
}

NODE * OutQ(void)
{
	return &(Q[Rp++]);
}

void Init_Visit(void)
{
	int i, j;

	for (i = 0; i < N; i++)
	{
		for (j = 0; j < M; j++)
		{
			Visit[i][j] = 0;
		}
	}
}

void Operation(void)
{
	int i, j, r;

	Max = 0;
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < M; j++)
		{
			if (Map[i][j] == 1)
			{
				r = BFS(i, j, 0);
				if (Max < r) Max = r;
				Init_Visit();
			}
		}
	}

}

int BFS(int sy, int sx, int sd)
{
	NODE * out = (NODE *)0x0;
	int i, j;
	int max_shipja;
	int ny, nx, nd;
	int Max_Size = 0;

	Wp = Rp = 0;
	dir = 0;
	InQ(sy, sx, sd);
	Visit[sy][sx] = 1;
	Max_Size = 1;
	min_shipja = MIN((N - sy) / 2, MIN(M - sx, sx));

	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;
		sx = out->x;
		sd = out->direction;
		for (i = 1; i <= min_shipja; i++)
		{
			sy += dy[dir];
			sx += dx[dir];
			if (Map[sy][sx])
		}
	}

	return Max_Size;
}

void Print_Visit(void)
{
	int i, j;

	printf("\n");
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < M; j++)
		{
			printf("%d ", Visit[i][j]);
		}
		printf("\n");
	}
	printf("\n\n");
}

/*
int BFS(int sy, int sx)
{
NODE * out = (NODE *)0x0;
int i;
int ny, nx;
int Max_Size = 0;
int check;
//int level = 0;
//if (Map[sy][sx] == 1) Max_Size = 1;

InQ(sy, sx);
Visit[sy][sx] = 1;
//Visit_Check[1]++;

printf("==================================\n");

while (Wp > Rp)
{
printf("Yop!!\n");
out = OutQ();
sy = out->y;
sx = out->x;
for (i = 0; i < 4; i++)
{
ny = sy + dy[i];
nx = sx + dx[i];
if ( ny < 1 || ny > N || nx < 1 || nx > M ) continue;
if (Visit[ny][nx] == 0 && Map[ny][nx] == 1)
{
check = Visit[sy][sx] + 1;
if (Visit[ny][nx] == check) Max_Size = (check + 1) / 2;
else
{
InQ(ny, nx);
Visit[ny][nx] = check;
}
}
}
}

printf("Max_Size = %d\n", Max_Size);

return Max_Size;
}*/
#endif




// 20190920
// 2105. [모의 SW 역량테스트] 디저트 카페
#if 0
#include <stdio.h>
#define MAX (22)
#define MAX_DESSERT (101)

void Input(void);
void Operation(void);
void DFS(int L, int y, int x, int cnt);
void Print_List(int cnt);

int T;
int N;
int Cafe[MAX][MAX];
int dy[4] = { 1, 1, -1, -1 };
int dx[4] = { 1, -1, -1, 1 };
int List[MAX];  // 어떤 디저트 메뉴가 들어갔는지 확인하기 위한 배열
int Visit[MAX_DESSERT]; // DFS 함수에서 나오면서 Visit배열은 0으로 초기화되기 때문에 따로 초기화 함수 만들 필요 없음
int Max_Dessert;        // 최종 결과값을 저장하기 위함. 최대값 갱신
int sy, sx;

int main(void)
{
	int i;

	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Input();
		Operation();
		printf("#%d %d\n", i, ((Max_Dessert == 0) ? -1 : Max_Dessert));
	}

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d", &N);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &Cafe[i][j]);
		}
	}
}

void Operation(void)
{
	int i, j;
	Max_Dessert = 0;

	for (i = 1; i < N; i++)
	{
		for (j = 2; j < N; j++)
		{
			sy = i;         sx = j; // 전역변수로서 DFS 함수 내에서 L이 3 -> 4로 증가할 때 처음 시작한 곳이랑 같은지 판단해주기 위함
			Visit[Cafe[sy][sx]] = 1;      // 처음 시작하는 곳 방문 표시
			List[0] = Cafe[sy][sx];

			DFS(0, i, j, 1);

			List[0] = 0;
			Visit[Cafe[sy][sx]] = 0;
		}
		if (2 * (N - i) <= Max_Dessert) break; // 추가한 가지치기!
	}
}

void DFS(int L, int y, int x, int cnt)
{
	int ny, nx;

	if (L > 0 && y <= sy) return;   // 추가 가지치기! : 1) DFS 시작하자마자 그 다음 칸에 같은 디저트가 있는 경우 2) 좀 크게 돌아서 L == 3일 때, 시작 위치의 y보다 더 위로 올라가려는 경우!
	if (L >= 4)
	{
		// 처음 보낸 곳에서 만나는지? 조건
		if (y == sy + 1 && x == sx - 1)
		{
			//printf("cnt = %d\n", cnt);
			//Print_List(cnt);
			if (Max_Dessert < cnt) Max_Dessert = cnt;
		}
		return;
	}

	ny = y + dy[L];         nx = x + dx[L];
	if (ny < 1 || ny > N || nx < 1 || nx > N) return;
	if (Visit[Cafe[ny][nx]] == 1)
	{
		// 같은 메뉴가 있었을 때는 꺾음
		DFS(L + 1, y, x, cnt);
	}
	else
	{
		// 같은 메뉴가 없더라도 꺾음
		Visit[Cafe[ny][nx]] = 1;
		List[cnt++] = Cafe[ny][nx];

		DFS(L + 1, ny, nx, cnt); // 생각해주지 못한 조건 2 : y, x로 보내면 그냥 꺾게되므로 처음에 잘 안 됨..!!

		//List[--cnt] = 0;
		//Visit[Cafe[ny][nx]] = 0;


		// 같은 메뉴가 없기 때문에 더 감

		//Visit[Cafe[ny][nx]] = 1;
		//List[cnt++] = Cafe[ny][nx];

		DFS(L, ny, nx, cnt); // L = 3일 때도 쭉 가다가 처음 시작한 곳 직전까지 갔으면, 거기서 그 다음 쭉 간 곳에 방문표시가 됐기 때문에 L = 3 -> 4로 바뀔 것!

		List[--cnt] = 0;
		Visit[Cafe[ny][nx]] = 0;
	}
}

void Print_List(int cnt)
{
	int i;

	for (i = 0; i < cnt; i++)
	{
		printf("%d ", List[i]);
	}
	printf("\n\n");
}
#endif





// 20190922
// 14503: 로봇 청소기;
#if 0
#include <stdio.h>
#define MAX     (55)

void Input(void);
void Operation(void);
void Print(void);

int N, M;
int r, c;
int dir;
int dy[4] = { -1, 0, 1, 0 };
int dx[4] = { 0, 1, 0, -1 };
int Map[MAX][MAX];
int Visit[MAX][MAX];
int cnt;

int main(void)
{
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d %d", &N, &M);
	scanf("%d %d %d", &r, &c, &dir);
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < M; j++)
		{
			scanf("%d", &Map[i][j]);
		}
	}
}

void Operation(void)
{
	int check;
	int nr, nc;

	cnt = 0;
	while (Map[r][c] != 1)
	{
		if (Map[r][c] == 0 || Visit[r][c] == 0)
		{
			cnt++;
			Visit[r][c] = 2;
			check = 0;
		}

		if (check == 4)
		{
			r += dy[(dir + 2) % 4];
			c += dx[(dir + 2) % 4];
			check = 0;
			continue;
		}

		dir = (dir + 3) % 4;
		nr = r + dy[dir];       nc = c + dx[dir];
		//if(nr < 0 || nr >= N || nc < 0 || nc >= M) continue;
		if (Map[nr][nc] == 0 && Visit[nr][nc] == 0)
		{
			r = nr;   c = nc;
			//check = 0;
		}
		else
		{
			check++;
		}
	}
}

void Print(void)
{
	printf("%d\n", cnt);
}
#endif

// ★광은님 코드 - 깔끔쓰!!! =>내 방식으로 바꿔보자!! ★
// => 조금 더 함수 내 각 블럭들이 확실히 구분된 느낌이고, 각 모듈의 역할을 더욱 명확히 할 수 있었음!!
#if 0
#include <stdio.h>
#define MAX     (55)
#define CLEAN   (2)

void Input(void);
void Operation(void);
void Print(void);

int N, M;
int r, c;
int dir;
int dy[4] = { -1, 0, 1, 0 };
int dx[4] = { 0, 1, 0, -1 };
int Map[MAX][MAX];
int cnt;

int main(void)
{
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d %d", &N, &M);
	scanf("%d %d %d", &r, &c, &dir);
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < M; j++)
		{
			scanf("%d", &Map[i][j]);
		}
	}
}

void Operation(void)
{
	int i;
	int check;
	int nr, nc;

	cnt = 0;
	while (Map[r][c] != 1)
	{
		if (Map[r][c] == 0)
		{
			cnt++;
			Map[r][c] = CLEAN;
		}

		for (i = 0; i < 4; i++)
		{
			dir = (dir + 3) % 4;
			nr = r + dy[dir];
			nc = c + dx[dir];
			if (Map[nr][nc] == 0)
			{
				r = nr;         c = nc;
				break;
			}
		}

		if (i == 4)
		{
			r += dy[(dir + 2) % 4];
			c += dx[(dir + 2) % 4];
		}
	}
}

void Print(void)
{
	printf("%d\n", cnt);
}
#endif`




// 20190922
// 14501: 퇴사    => DFS 본질 더욱 잘 파악하기 ㅠㅠ
#if 0
#include <stdio.h>
#define MAX     (20)

void Input(void);
//void Operation(void);
void DFS(int L, int sum);
void Print(void);

int N;
int Ti[MAX];
int Pi[MAX];
int Max_Profit;
//int Check[MAX][MAX];
//int ROD[MAX];
int List[MAX];
int cnt;

int main(void)
{
	Input();
	//Operation();
	DFS(1, 0);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;
	int flag;

	scanf("%d", &N);
	for (i = 1; i <= N; i++)
	{
		scanf("%d %d", &Ti[i], &Pi[i]);
		//flag = 0;
		//if(i + Ti[i] - 1 > N) flag = 1;
		//for(j = i; j < i + Ti[i]; j++)
		//{
		//        if(flag) break;
		//        Check[i][j] = Ti[i];
		//}
	}
}

void DFS(int L, int sum)
{
	if (L > N)
	{
		if (Max_Profit < sum) Max_Profit = sum;
		return;
	}

	if (L + Ti[L] - 1 <= N)
	{
		List[cnt++] = Pi[L];
		DFS(L + Ti[L], sum + Pi[L]);
		List[--cnt] = 0;
	}
	//else DFS(L + 1, sum);

	DFS(L + 1, sum);
}

/*
void Operation(void)
{
int i, j, k;
int sum = 0;
int flag;

Max_Profit = 0;
for(k = 1; k <= N; k++)
{
sum = 0;
for(i = k; i <= N; i++)
{
if(ROD[i] != 0) continue;
flag = 0;
if(i + Ti[i] - 1 > N) flag = 1;
if(flag) continue;
for(j = i; j < i + Ti[i]; j++)
{
ROD[j] = Ti[i];
}
sum += Pi[i];
}
if(Max_Profit < sum) Max_Profit = sum;
}
}
*/

void Print(void)
{
	/*
	int i, j;

	for(i = 1; i <= N; i++)
	{
	for(j = 1; j <= N; j++)
	{
	printf("%d ", Check[i][j]);
	}
	printf("\n");
	}
	printf("\n");
	*/
	printf("%d\n", Max_Profit);
}
#endif

// 더욱 깔끔한 DFS!!
#if 0
#include <stdio.h>
#define MAX     (20)

void Input(void);
void DFS(int L, int sum);
void Print(void);

int N;
int Ti[MAX];
int Pi[MAX];
int Max_Profit;
int List[MAX];
int cnt;

int main(void)
{
	Input();
	DFS(1, 0);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	Max_Profit = 0;
	scanf("%d", &N);
	for (i = 1; i <= N; i++)
	{
		scanf("%d %d", &Ti[i], &Pi[i]);
	}
}

void DFS(int L, int sum)
{
	int i;

#if 01
	// Ver. 1
	if (L > N)
	{
		if (Max_Profit < sum) Max_Profit = sum;
		return;
	}

	if (L + Ti[L] - 1 <= N)
	{
		List[cnt++] = Pi[L];
		DFS(L + Ti[L], sum + Pi[L]);
		List[--cnt] = 0;
	}

	DFS(L + 1, sum);
#else
	// Ver. 2
	if (L > N + 1) return;
	if (Max_Profit < sum) Max_Profit = sum;

	for (i = L; i <= N; i++)
	{
		DFS(i + Ti[L], sum + Pi[L]);
	}
#endif
}
void Print(void)
{
	printf("%d\n", Max_Profit);
}
#endif



// 20190923
// 문제 E9: [TST] Snake	: 몇 초 후에 게임이 끝나는지!!!!
#if 0
#include <stdio.h>
#define MM	(101)
#define MAX	(10001)
#define FRUIT		(3)
#define SNAKE		(2)
#define WALLORSNAKE	(1)
#define BLANK		(0)

typedef struct
{
	int T;
	char C;
}COMMAND;
COMMAND Com[MAX];

typedef struct
{
	int y, x;
}NODE;
NODE Q[MM * MM * 10];


void Input(void);
void Operation(void);
void Print(void);

int Map[MM][MM];
int N, K, L;
int time;
int Wp, Rp;

int main(void)
{
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, r, c;

	scanf("%d", &N);
	for (i = 0; i <= N + 1; i++)
	{
		Map[0][i] = Map[i][0] = Map[N + 1][i] = Map[i][N + 1] = WALLORSNAKE;
	}

	scanf("%d", &K);
	for (i = 1; i <= K; i++)
	{
		scanf("%d %d", &r, &c);
		Map[r][c] = FRUIT;
	}

	scanf("%d", &L);
	for (i = 1; i <= L; i++) scanf("%d %c", &Com[i].T, &Com[i].C);
}

void Operation(void)
{
	int i, j;
	int order = 1;
	int dir = 0;
	int dy[4] = { 0, -1, 0, 1 };
	int dx[4] = { 1, 0, -1, 0 };
	int HEAD;
	int tmp;
	Wp = Rp = 0;

	time = 0;
	Q[Wp].y = 1;
	Q[Wp++].x = 1;
	HEAD = Wp - 1;

	for (;;)
	{
		Map[Q[HEAD].y][Q[HEAD].x] = WALLORSNAKE;
		Q[Wp].y = Q[HEAD].y + dy[dir];
		Q[Wp++].x = Q[HEAD].x + dx[dir];
		HEAD = Wp - 1;
		if (Map[Q[HEAD].y][Q[HEAD].x] == WALLORSNAKE) break;

		if (Map[Q[HEAD].y][Q[HEAD].x] != FRUIT)
		{
			Map[Q[Rp].y][Q[Rp].x] = BLANK;
			Rp++;
		}

		time++;
		if (time == Com[order].T)
		{
			if (Com[order].C == 'L')
			{
				dir = (dir + 1) % 4;
			}
			else
			{
				dir = (dir + 3) % 4;
			}
			order++;
		}

		/* 디버깅을 위해서!
		printf("====================\n");
		printf("time = %d\n", time);
		for (i = 0; i <= N + 1; i++)
		{
		for (j = 0; j <= N + 1; j++)
		{
		printf("%d ", Map[i][j]);
		}
		printf("\n");
		}
		printf("\n");
		printf("Length = %d\n", Wp - Rp);
		printf("====================\n");
		*/
	}
}

void Print(void)
{
	printf("%d\n", time + 1);
}
#endif




// 20190923
// 2382. [모의 SW 역량테스트] 미생물 격리
#if 0
#include <stdio.h>
#define MAX_MIC (1001)
#define MAX (110)

typedef struct
{
	int y, x;
	int count;
	int dir;
}MIC;
MIC mic[MAX_MIC];

typedef struct
{
	int num;
	int max;
	int dir;
}CHECK;
CHECK chk[MAX][MAX];

void Input(void);
void InQ(int yy, int xx, int n, int d);
MIC * OutQ(void);
void IInnQQ(void);
void Init_Check(void);
void Operation(void);
int Print(void);

int T;
int N, K, M;
int dy[4] = { -1, 0, 1, 0 };
int dx[4] = { 0, -1, 0, 1 };
int Wp, Rp;

int main(void)
{
	int i, j;

	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Input();
		Operation();
		printf("#%d %d\n", i, Print());
	}

	return 0;
}

void Input(void)
{
	int r, c, tcount, tdir;
	int i;

	Wp = Rp = 0;
	scanf("%d %d %d", &N, &M, &K);
	for (i = 1; i <= K; i++)
	{
		scanf("%d %d %d %d", &r, &c, &tcount, &tdir);
		switch (tdir)
		{
		case 1:
			tdir = 0;
			break;
		case 2:
			tdir = 2;
			break;
		case 3:
			tdir = 1;
			break;
		default:
			tdir = 3;
			break;
		}
		InQ(r, c, tcount, tdir);
	}
}

void InQ(int yy, int xx, int n, int d)
{
	mic[Wp].y = yy;
	mic[Wp].x = xx;
	mic[Wp].count = n;
	mic[Wp++].dir = d;
}

MIC * OutQ(void)
{
	return &(mic[Rp++]);
}

void Operation(void)
{
	int i;
	int ny, nx, nc, nd;
	MIC * out = (MIC *)0x0;

	while (M--)
	{
		for (i = 0; i < Wp; i++)
		{
			out = OutQ();
			nd = out->dir;
			ny = out->y + dy[nd];
			nx = out->x + dx[nd];
			nc = out->count;
			if (ny == 0 || ny == N - 1 || nx == 0 || nx == N - 1)
			{
				nc /= 2;
				nd = (nd + 2) % 4;
			}
			chk[ny][nx].num += nc;
			if (chk[ny][nx].max < nc)
			{
				chk[ny][nx].max = nc;
				chk[ny][nx].dir = nd;
			}
		}
		IInnQQ();
		Init_Check();
	}
}

void IInnQQ(void)
{
	int i, j;

	Wp = Rp = 0;
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			if (chk[i][j].num > 0)
			{
				InQ(i, j, chk[i][j].num, chk[i][j].dir);
			}
		}
	}
}

void Init_Check(void)
{
	int i, j;

	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			chk[i][j].num = 0;
			chk[i][j].max = 0;
			chk[i][j].dir = 0;
		}
	}
}

int Print(void)
{
	int i, j, sum = 0;

	for (i = 0; i < Wp; i++)
	{
		sum += mic[i].count;
	}

	return sum;
}
#endif

// 비슷하지만 조금 다른 버전
#if 0
#include <stdio.h>
#define MAX_MIC (1001)
#define MAX (110)

typedef struct
{
	int y, x;
	int count;
	int dir;
}MIC;
MIC mic[MAX_MIC];

typedef struct
{
	int num;
	int max;
	int dir;
}CHECK;
CHECK chk[MAX][MAX];

void Input(void);
void InQ(int yy, int xx, int n, int d);
MIC * OutQ(void);
void IInnQQ(void);
void Init_Check(void);
void Operation(void);
int Print(void);

int T;
int N, K, M;
int dy[5] = { 0, -1, 1, 0, 0 };
int dx[5] = { 0, 0, 0, -1, 1 };
int Wp, Rp;

int main(void)
{
	int i;

	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Input();
		Operation();
		printf("#%d %d\n", i, Print());
	}

	return 0;
}

void Input(void)
{
	int r, c, tcount, tdir;
	int i;

	Wp = Rp = 0;
	scanf("%d %d %d", &N, &M, &K);
	for (i = 1; i <= K; i++)
	{
		scanf("%d %d %d %d", &r, &c, &tcount, &tdir);
		InQ(r, c, tcount, tdir);
	}
}

void InQ(int yy, int xx, int n, int d)
{
	mic[Wp].y = yy;
	mic[Wp].x = xx;
	mic[Wp].count = n;
	mic[Wp++].dir = d;
}

MIC * OutQ(void)
{
	return &(mic[Rp++]);
}

void Operation(void)
{
	int i;
	int ny, nx, nc, nd;
	MIC * out = (MIC *)0x0;

	while (M--)
	{
		for (i = 0; i < Wp; i++)
		{
			out = OutQ();
			nd = out->dir;
			ny = out->y + dy[nd];
			nx = out->x + dx[nd];
			nc = out->count;
			if (ny == 0 || ny == N - 1 || nx == 0 || nx == N - 1)
			{
				nc /= 2;
				nd = ((nd & 1) ? (nd + 1) : (nd - 1));
			}
			chk[ny][nx].num += nc;
			if (chk[ny][nx].max < nc)
			{
				chk[ny][nx].max = nc;
				chk[ny][nx].dir = nd;
			}
		}
		IInnQQ();
		Init_Check();
	}
}

void IInnQQ(void)
{
	int i, j;

	Wp = Rp = 0;
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			if (chk[i][j].num > 0)
			{
				InQ(i, j, chk[i][j].num, chk[i][j].dir);
			}
		}
	}
}

void Init_Check(void)
{
	int i, j;

	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			chk[i][j].num = 0;
			chk[i][j].max = 0;
			chk[i][j].dir = 0;
		}
	}
}

int Print(void)
{
	int i, sum = 0;

	for (i = 0; i < Wp; i++)
	{
		sum += mic[i].count;
	}

	return sum;
}
#endif

// 쉬프트도 한 번.. ㅋㅋ
#if 0
#include <stdio.h>
#define MAX_MIC (1001)
#define MAX (110)

typedef struct
{
	int y, x;
	int count;
	int dir;
}MIC;
MIC mic[MAX_MIC];

typedef struct
{
	int num;
	int max;
	int dir;
}CHECK;
CHECK chk[MAX][MAX];

void Input(void);
void InQ(int yy, int xx, int n, int d);
MIC * OutQ(void);
void IInnQQ(void);
void Operation(void);
int Print(void);

int T;
int N, K, M;
int dy[5] = { 0, -1, 1, 0, 0 };
int dx[5] = { 0, 0, 0, -1, 1 };
int dd[5] = { 0, 2, 1, 4, 3 };
int Wp, Rp;

int main(void)
{
	int i, j;

	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Input();
		Operation();
		printf("#%d %d\n", i, Print());
	}

	return 0;
}

void Input(void)
{
	int r, c, tcount, tdir;
	int i;

	Wp = Rp = 0;
	scanf("%d %d %d", &N, &M, &K);
	for (i = 1; i <= K; i++)
	{
		scanf("%d %d %d %d", &r, &c, &tcount, &tdir);
		InQ(r, c, tcount, tdir);
	}
}

void InQ(int yy, int xx, int n, int d)
{
	mic[Wp].y = yy;
	mic[Wp].x = xx;
	mic[Wp].count = n;
	mic[Wp++].dir = d;
}

MIC * OutQ(void)
{
	return &(mic[Rp++]);
}

void Operation(void)
{
	int i;
	int ny, nx, nc, nd;
	MIC * out = (MIC *)0x0;

	while (M--)
	{
		for (i = 0; i < Wp; i++)
		{
			out = OutQ();
			nd = out->dir;
			ny = out->y + dy[nd];
			nx = out->x + dx[nd];
			nc = out->count;
			if (ny == 0 || ny == N - 1 || nx == 0 || nx == N - 1)
			{
				nc >>= 1;
				nd = dd[nd];
			}
			chk[ny][nx].num += nc;
			if (chk[ny][nx].max < nc)
			{
				chk[ny][nx].max = nc;
				chk[ny][nx].dir = nd;
			}
		}
		IInnQQ();
	}
}

void IInnQQ(void)
{
	int i, j;
	CHECK tmp = { 0 };

	Wp = Rp = 0;
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			if (chk[i][j].num > 0)
			{
				InQ(i, j, chk[i][j].num, chk[i][j].dir);
			}
			if (chk[i][j].max > 0)
			{
				chk[i][j] = tmp;
			}
		}
	}
}

int Print(void)
{
	int i, j, sum = 0;

	for (i = 0; i < Wp; i++)
	{
		sum += mic[i].count;
	}

	return sum;
}
#endif

// 제출 ver.
#if 0
#include <stdio.h>
#define MAX_MIC (1001)
#define MAX (110)

// 미생물 군집 구조체
typedef struct
{
	int y, x;
	int count;
	int dir;
}MIC;
MIC mic[MAX_MIC];

// 미생물 군집의 이동에 따라 한 셀에 모이는 경우를 판단해주기 위한 구조체
typedef struct
{
	int num;
	int max;
	int dir;
}CHECK;
CHECK chk[MAX][MAX];

void Input(void);
void InQ(int yy, int xx, int n, int d);
MIC * OutQ(void);
void IInnQQ(void);
void Operation(void);
int Print(void);

int T;
int N, K, M;
int dy[5] = { 0, -1, 1, 0, 0 };
int dx[5] = { 0, 0, 0, -1, 1 };
int dd[5] = { 0, 2, 1, 4, 3 };
int Wp, Rp;

int main(void)
{
	int i;

	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Input();
		Operation();
		printf("#%d %d\n", i, Print());
	}

	return 0;
}

void Input(void)
{
	int r, c, tcount, tdir;
	int i;

	Wp = Rp = 0;
	scanf("%d %d %d", &N, &M, &K);
	for (i = 1; i <= K; i++)
	{
		scanf("%d %d %d %d", &r, &c, &tcount, &tdir);
		InQ(r, c, tcount, tdir);	// 입력 초기 미생물 군집을 Q에 넣어주기 위한 함수
	}
}

void InQ(int yy, int xx, int n, int d)
{
	mic[Wp].y = yy;
	mic[Wp].x = xx;
	mic[Wp].count = n;
	mic[Wp++].dir = d;
}

MIC * OutQ(void)
{
	return &(mic[Rp++]);
}

void Operation(void)
{
	int i;
	int ny, nx, nc, nd;
	MIC * out = (MIC *)0x0;

	while (M--)	// M시간 격리된 후의 상황을 보자!
	{
		for (i = 0; i < Wp; i++)	// 미생물 군집들이 모두 한 번씩 움직임
		{
			out = OutQ();
			nd = out->dir;
			ny = out->y + dy[nd];
			nx = out->x + dx[nd];
			nc = out->count;
			if (ny == 0 || ny == N - 1 || nx == 0 || nx == N - 1)	// 약품이 칠해진 구역으로 갔을 때!
			{
				nc >>= 1;		// 미생물 수가 절반이 되고,
				nd = dd[nd];	// 이동 방향은 반대가 된다.
			}
			chk[ny][nx].num += nc;		// 이동 후(&& 한 셀에 모인), 미생물의 수
			if (chk[ny][nx].max < nc)
			{
				chk[ny][nx].max = nc;
				chk[ny][nx].dir = nd;	// 이동 후(&& 한 셀에 모인 경우), 미생물 군집의 방향 판단
			}
		}
		IInnQQ();	// 다음 시간(M - 1)에 미생물들을 이동시키기 위해서 다시 Q에 넣어주고, chk[][] 구조체는 초기화!
	}
}

void IInnQQ(void)
{
	int i, j;

	Wp = Rp = 0;
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			if (chk[i][j].num > 0)
			{
				InQ(i, j, chk[i][j].num, chk[i][j].dir);
			}
			if (chk[i][j].max > 0)
			{
				chk[i][j].num = 0;
				chk[i][j].max = 0;
			}
		}
	}
}

int Print(void)
{
	int i, sum = 0;

	for (i = 0; i < Wp; i++)
	{
		sum += mic[i].count;	// 남아 있는 미생물의 총 수
	}

	return sum;
}
#endif







// 20190924
// 벽장문의 이동
/*
	- 눈 앞에 가까운 곳만 방문할 것이 아니라, 지금 당장 멀더라도 나중에 효율적일 수도 있음!!
	- ★그렇기 때문에 이러할 가능성이 있다면, 완전탐색처럼 조금 멀리라도 가야 마땅!★
*/
#if 0
#include <stdio.h>
#define MAX	(21)
#define ABS(a)	( ((a) < 0) ? -(a) : (a) )

void Input(void);
void DFS(int L, int cnt);
void Print(void);

int n, m;
int open1, open2;
int door[MAX];
int order[MAX];
int Min;

int main(void)
{
	Input();
	DFS(1, 0);
	Print();

	return 0;
}

void Input(void)
{
	int i;

	Min = 987654321;
	scanf("%d", &n);
	scanf("%d %d", &open1, &open2);
	door[ open1 ] = door[ open2 ] = 1;	// 열려있다!!
	scanf("%d", &m);
	for (i = 1; i <= m; i++) scanf("%d", &order[i]);
}

void DFS(int L, int cnt)
{
	int a, b;
	int tmp;

	if (cnt >= Min) return;
	if (L > m)
	{
		if (Min > cnt) Min = cnt;
		return;
	}

	if ( door[ order[L] ] == 1 )	// 열려있다면?
	{
		DFS(L + 1, cnt);
	}
	else // 닫혀있다면?
	{
		a = ABS(open1 - order[L]);
		b = ABS(open2 - order[L]);

		door[open1] = 0;	door[order[L]] = 1;
		tmp = open1;		open1 = order[L];
		DFS(L + 1, cnt + a);
		order[L] = open1;	open1 = tmp;
		door[open1] = 1;	door[order[L]] = 0;

		door[open2] = 0;	door[order[L]] = 1;
		tmp = open2;		open2 = order[L];
		DFS(L + 1, cnt + b);
		order[L] = open2;	open2 = tmp;
		door[open2] = 1;	door[order[L]] = 0;
		/*if ( a <= b )
		{
			door[open1] = 0;	door[order[L]] = 1;
			tmp = open1;		open1 = order[L];		
			DFS(L + 1, cnt + a);
			order[L] = open1;	open1 = tmp;
			door[ open1 ] = 1;	door[ order[L] ] = 0;
		}
		if ( a >= b )
		{
			door[ open2 ] = 0;	door[ order[L] ] = 1;
			tmp = open2;		open2 = order[L];
			DFS(L + 1, cnt + b);
			order[L] = open2;	open2 = tmp;
			door[ open2 ] = 1;	door[ order[L] ] = 0;
		}*/
	}
}

void Print(void)
{
	printf("%d\n", Min);
}
#endif




// 20190924
// [BOJ. 17144] 미세먼지 안녕!
#if 0
#include <stdio.h>
#define MAX	(52)

void Input(void);
void Operation(void);
void Cleaner1(void);
void Cleaner2(void);
void Arr_Copy(void);
void Print(void);

int R, C;
int T;
int Room[MAX][MAX];
int chk_Room[MAX][MAX];
int Remain_Dust;
int cleaner_y[2];
int cleaner_x[2];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

int main(void)
{
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, j, order = 0;

	Remain_Dust = 2;
	scanf("%d %d %d", &R, &C, &T);
	for (i = 1; i <= R; i++)
	{
		for (j = 1; j <= C; j++)
		{
			scanf("%d", &Room[i][j]);
			Remain_Dust += Room[i][j];
			if ( Room[i][j] == -1 )
			{
				cleaner_y[order] = i;
				cleaner_x[order++] = j;
			}
		}
	}
	//printf("Remain_Dust = %d\n", Remain_Dust);
}

void Operation(void)
{
	int i, j, k, ny, nx;
	int diff;

	while (T--)
	{	// 1) 이중for문 돌면서 먼지가 있으면 4방으로 확산해주는 단계
		for (i = 1; i <= R; i++)
		{
			for (j = 1; j <= C; j++)
			{
				if (Room[i][j] >= 0)
				{
					diff = Room[i][j] / 5;
					for (k = 0; k < 4; k++)
					{
						ny = i + dy[k];
						nx = j + dx[k];
						if (ny < 1 || ny > R || nx < 1 || nx > C || Room[ny][nx] == -1) continue;
						chk_Room[ny][nx] += diff;
						Room[i][j] -= diff;
					}
					chk_Room[i][j] += Room[i][j];
				}
			}
		}
		
		chk_Room[cleaner_y[0]][cleaner_x[0]] = -1;
		chk_Room[cleaner_y[1]][cleaner_x[1]] = -1;

		/*
		for (i = 0; i <= R + 1; i++)
		{
			for (j = 0; j <= C + 1; j++)
			{
				printf("%3d", chk_Room[i][j]);
			}
			printf("\n");
		}
		printf("\n");
		*/

		// 2) 일단 확산을 다 시키고 Cleaner1, 2 함수를 통해 공기청정기를 돌리는 단계
		Cleaner1();
		Cleaner2();

		// 3) Room배열에 chk_Room 배열을 복사하고, 확산에 사용해줬던 chk_Room 배열을 초기화 하는 단계
		Arr_Copy();
	}
}

void Cleaner1(void)
{
	int i, yy = cleaner_y[0];

	Remain_Dust -= chk_Room[yy - 1][1];
	// 좌
	for (i = yy - 2; i >= 1; i--) chk_Room[i + 1][1] = chk_Room[i][1];
	// 상
	for (i = 2; i <= C; i++) chk_Room[1][i - 1] = chk_Room[1][i];
	// 우
	for (i = 2; i <= yy; i++) chk_Room[i - 1][C] = chk_Room[i][C];
	// 하
	for (i = C - 1; i >= 2; i--) chk_Room[yy][i + 1] = chk_Room[yy][i];
	chk_Room[yy][2] = 0;
}

void Cleaner2(void)
{
	int i, yy = cleaner_y[1];

	Remain_Dust -= chk_Room[yy + 1][1];
	// 좌
	for (i = yy + 2; i <= R; i++) chk_Room[i - 1][1] = chk_Room[i][1];
	// 하
	for (i = 2; i <= C; i++) chk_Room[R][i - 1] = chk_Room[R][i];
	// 우
	for (i = R - 1; i >= yy; i--) chk_Room[i + 1][C] = chk_Room[i][C];
	// 상
	for (i = C - 1; i >= 2; i--) chk_Room[yy][i + 1] = chk_Room[yy][i];
	chk_Room[yy][2] = 0;
}

void Arr_Copy(void)
{
	int i, j;

	for (i = 1; i <= R; i++)
	{
		for (j = 1; j <= C; j++)
		{
			Room[i][j] = chk_Room[i][j];
			chk_Room[i][j] = 0;
		}
	}
}

void Print(void)
{
	printf("%d\n", Remain_Dust);
}
#endif




// 20190927 - 1
// [BOJ. 14890] 경사로
#if 0
#include <stdio.h>
#define MAX	(102)
#define ABS(a) ( ((a) < 0) ? -(a) : (a) )

void Input(void);
void Operation(void);
void Print(void);

int N, L;
int Map[MAX][MAX];
int cnt;

int main(void)
{
	Input();
	Operation();
	Print();

	return 0; 
}

void Input(void)
{
	int i, j;

	cnt = 0;
	scanf("%d %d", &N, &L);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &Map[i][j]);
		}
	}
}

void Operation(void)
{
	int i, j;
	int floor, check;

	// 왼쪽에서 오른쪽!!
	for (i = 1; i <= N; i++)
	{
		floor = 1;
		for (j = 1; j < N; j++)
		{
			check = Map[i][j] - Map[i][j + 1];	// (+) -> 감소하고 있음, (-) -> 증가하고 있음
			if (ABS(check) > 1) break;
			else if (check == 0) floor++;
			else  // 차이가 1 !
			{
				if (check == -1) // 높아짐
				{
					if (floor >= L) floor = 1;
					else break;
				}
				else // 낮아짐 : 추가적인 판단이 필요( "ㄱㅡΓ" 의 경우, "ㅡ"(낮은 부분의 바닥)에 해당되는 최소 개수가 2 * L개임!! )
				{
					if (floor < 0) break;	// ★계속 계단식으로 내려가는 경우를 잡기 위함!!★
					floor = 1 - L;
				}
			}
		}
		if (j == N && floor >= 0) cnt++;
		// ★제일 마지막에도 이 조건을 붙여주지 않는다면, 계속 계단식으로 내려가는 경우를 잘 잡을 수 없음★
	}

	// 위에서 아래로 (좌 -> 우와 방향만 다르고 다 똑같음!)
	for (i = 1; i <= N; i++)
	{
		floor = 1;
		for (j = 1; j < N; j++)
		{
			check = Map[j][i] - Map[j + 1][i];	// (+) -> 감소하고 있음, (-) -> 증가하고 있음
			if (ABS(check) > 1) break;
			else if (check == 0) floor++;
			else  // 차이가 1 !
			{
				if (check == -1) // 높아짐
				{
					if (floor >= L) floor = 1;
					else break;
				}
				else // 낮아짐
				{
					if (floor < 0) break;	// ★계속 계단식으로 내려가는 경우를 잡기 위함!!★
					floor = 1 - L;
				}
			}
		}
		if (j == N && floor >= 0) cnt++;
		// ★제일 마지막에도 이 조건을 붙여주지 않는다면, 계속 계단식으로 내려가는 경우를 잘 잡을 수 없음★
	}
}

void Print(void)
{
	printf("%d\n", cnt);
}
#endif




// 20190927 - 2
// [BOJ. 14891] 톱니바퀴
#if 0
#include <stdio.h>
#define MAX     (101)

// 톱니바퀴
typedef struct
{
	int ARR[8];
	int dir;
}SAW;
SAW S[5];

// K개의 명령어를 담는 틀
typedef struct
{
	int saw;
	int dir;
}COMMAND;
COMMAND C[MAX];

void Input(void);
void Operation(void);
void Rotate_Clock(void);
void Print(void);

int K;
int Result[5][2] = { { 0, 0 }, { 0, 1 }, { 0, 2 }, { 0, 4 }, { 0, 8 } };	// 최종 결과 점수 판단 위함!
int Final_Score;

int main(void)
{
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	for (i = 1; i <= 4; i++)
	{
		for (j = 0; j < 8; j++)
		{
			scanf("%1d", &S[i].ARR[j]);
		}
	}
	scanf("%d", &K);
	for (i = 1; i <= K; i++) scanf("%d %d", &C[i].saw, &C[i].dir);
}

void Operation(void)
{
	int i, n;

	for (i = 1; i <= K; i++)
	{
		n = C[i].saw;
		S[n].dir = C[i].dir;
		// 오른쪽으로
		while (n < 4)
		{
			if (S[n].ARR[2] != S[n + 1].ARR[6])
			{
				S[n + 1].dir = S[n].dir * (-1);
			}
			else S[n + 1].dir = 0;
			n++;
		}

		n = C[i].saw;
		// 왼쪽으로
		while (n > 1)
		{
			if (S[n].ARR[6] != S[n - 1].ARR[2])
			{
				S[n - 1].dir = S[n].dir * (-1);
			}
			else S[n - 1].dir = 0;
			n--;
		}
		Rotate_Clock();
	}
}

void Rotate_Clock(void)
{
	int i, j, tmp;

	for (i = 1; i <= 4; i++)
	{
		if (S[i].dir == 1)
		{
			tmp = S[i].ARR[7];
			for (j = 6; j >= 0; j--)
			{
				S[i].ARR[j + 1] = S[i].ARR[j];
			}
			S[i].ARR[0] = tmp;
		}
		else if (S[i].dir == -1)
		{
			tmp = S[i].ARR[0];
			for (j = 1; j <= 7; j++)
			{
				S[i].ARR[j - 1] = S[i].ARR[j];
			}
			S[i].ARR[7] = tmp;
		}
	}
}

void Print(void)
{
	int i, j;
	Final_Score = 0;

	for (i = 1; i <= 4; i++)
	{
		Final_Score += Result[i][S[i].ARR[0]];
	}
	printf("%d\n", Final_Score);
}
#endif

// 20190930
// [BOJ. 15662] 톱니바퀴(2)
#if 0
#include <stdio.h>
#define MAX     (1001)

typedef struct
{
	int ARR[8];
	int dir;
}SAW;
SAW S[MAX];

typedef struct
{
	int saw;
	int dir;
}COMMAND;
COMMAND C[MAX];

void Input(void);
void Operation(void);
void Rotate_Clock(void);
void Print(void);

int T;
int K;
int Final_Score;

int main(void)
{
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		for (j = 0; j < 8; j++)
		{
			scanf("%1d", &S[i].ARR[j]);
		}
	}
	scanf("%d", &K);
	for (i = 1; i <= K; i++) scanf("%d %d", &C[i].saw, &C[i].dir);
}

void Operation(void)
{
	int i, n;

	for (i = 1; i <= K; i++)
	{
		n = C[i].saw;
		S[n].dir = C[i].dir;
		// 오른쪽으로
		while (n < T)
		{
			if (S[n].ARR[2] != S[n + 1].ARR[6])
			{
				S[n + 1].dir = S[n].dir * (-1);
			}
			else S[n + 1].dir = 0;
			n++;
		}

		n = C[i].saw;
		// 왼쪽으로
		while (n > 1)
		{
			if (S[n].ARR[6] != S[n - 1].ARR[2])
			{
				S[n - 1].dir = S[n].dir * (-1);
			}
			else S[n - 1].dir = 0;
			n--;
		}
		Rotate_Clock();
	}
}

void Rotate_Clock(void)
{
	int i, j, tmp;

	for (i = 1; i <= T; i++)
	{
		if (S[i].dir == 1)
		{
			tmp = S[i].ARR[7];
			for (j = 6; j >= 0; j--)
			{
				S[i].ARR[j + 1] = S[i].ARR[j];
			}
			S[i].ARR[0] = tmp;
		}
		else if (S[i].dir == -1)
		{
			tmp = S[i].ARR[0];
			for (j = 1; j <= 7; j++)
			{
				S[i].ARR[j - 1] = S[i].ARR[j];
			}
			S[i].ARR[7] = tmp;
		}
	}
}

void Print(void)
{
	int i;
	Final_Score = 0;

	for (i = 1; i <= T; i++)
	{
		Final_Score += S[i].ARR[0];
	}
	printf("%d\n", Final_Score);
}
#endif





// 20191001
// R구슬과 B구슬이 "동시에" 구멍에 빠져도 시패!! 라는 조건을 무시...;;
#if 0
#include <stdio.h>
#define MAX     (15)

typedef struct
{
	int y, x;
}NODE;
NODE r;
NODE b;

void Input(void);
void DFS(int L, int ry, int rx, int by, int bx);
void Print(void);

int N, M;
char Board[MAX][MAX];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int flag;

int main(void)
{
	Input();
	DFS(1, r.y, r.x, b.y, b.x);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;
	char tmp[MAX];

	flag = 0;
	scanf("%d %d", &N, &M);
	for (i = 0; i < N; i++)
	{
		scanf("%s", tmp);
		for (j = 0; j < M; j++)
		{
			Board[i][j] = tmp[j];
			if (Board[i][j] == 'R')
			{
				r.y = i;
				r.x = j;
			}
			else if (Board[i][j] == 'B')
			{
				b.y = i;
				b.x = j;
			}
		}
	}
}

void DFS(int L, int ry, int rx, int by, int bx)
{
	int i, j, k;
	int nry, nrx, nby, nbx;

	//printf("L = %d, ry = %d, rx = %d, by = %d, bx = %d\n", L, ry, rx, by, bx);
	if (L > 10) return;

	for (i = 0; i < 4; i++)
	{
		nry = ry;               nrx = rx;
		nby = by;               nbx = bx;
		for (j = 0;; j++)
		{
			if ((Board[nry + dy[i]][nrx + dx[i]] == '#') || (Board[nry][nrx] == 'O')) break;
			nry += dy[i];
			nrx += dx[i];
		}
		for (k = 0;; k++)
		{
			if ((Board[nby + dy[i]][nbx + dx[i]] == '#') || (Board[nby][nbx] == 'O')) break;
			nby += dy[i];
			nbx += dx[i];
		}

		if (Board[nby][nbx] == 'O') continue;
		if (nry == nby && nrx == nbx)
		{
			if (j > k)
			{
				nry -= dy[i];
				nrx -= dx[i];
			}
			else
			{
				nby -= dy[i];
				nbx -= dx[i];
			}
		}

		if (Board[nry][nrx] == 'O')
		{
			flag = 1;
			break;
		}
		DFS(L + 1, nry, nrx, nby, nbx);
	}
}

void Print(void)
{
	printf("%d\n", flag);
}
#endif






// 20191003
// [BOJ. 15685] 드래곤 커브
#if 0
#include <stdio.h>
#define MAX	(101)
#define MAX_g	(10)

void Set_Data(void);
void Input(void);
void Cnt_Print(void);

int N;
int dir;
		   // 우, 상, 좌, 하
int dy[4] = { 0, -1, 0, 1 };
int dx[4] = { 1, 0, -1, 0 };
int cnt[11] = { 1, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };// idx = 세대, 값 = 그 세대 때 더 필요한 선분 개수
int dir_cnt[1050];	// 0 ~ g세대까지 1선분을 그릴 때의 방향을 모두 저장해놓은 배열
int Board[MAX][MAX];

int main(void)
{
	Set_Data();
	Input();
	Cnt_Print();

	return 0;
}

void Set_Data(void)	// 각 세대에서 "추가적으로" 그리는(?) 선분의 개수를 저장해놓은 배열을 만들기 위함
{
	int i;

	cnt[0] = cnt[1] = 1;
	for (i = 2; i <= MAX_g; i++)
	{
		cnt[i] = 2 * cnt[i - 1];
	}
}

void Input(void)
{
	int x, y, d, g;
	int i, j, k;
	int order;

	scanf("%d", &N);
	for (i = 0; i < N; i++)
	{
		scanf("%d %d %d %d", &x, &y, &d, &g);

		order = 1;			// 0세대 ~ g세대까지 1선분씩 커브를 그릴 때의 방향들을 모두 저장해주기 위함
		Board[y][x] = 1;			// 0세대 시작점
		dir_cnt[order] = d;			// 0세대 시작 방향
		y += dy[d];		x += dx[d];	// 0세대 끝점 좌표
		Board[y][x] = 1;			// 0세대 끝점
		// 일단 디폴트로 0세대 때의 커브를 그려놓고 시작

		for (j = 1; j <= g; j++)	// 1세대 ~ g세대까지 커브를 그림
		{
			//printf("cnt[세대 = %d] = %d, ", j, cnt[j]);
			for (k = cnt[j]; k >= 1; k--)	// 방향이 거꾸로 들어감..;;
			{
				dir = ( dir_cnt[k] + 1 ) % 4;		// 일단 기존의 방향에서 반시계방향으로 꺾음
				y += dy[dir];		x += dx[dir];	// 그 방향만큼 1선분 그림
				dir_cnt[++order] = dir;				// 그리고 그 방향을 다시 저장해놓음 (거꾸로 꺼내야 함!)
				//printf("y = %d, x = %d\n", y, x);
				if (y < 0 || y > 100 || x < 0 || x > 100) continue;	// 근데 그 좌표가 격자 범위를 넘어서면 그리지 않음
				Board[y][x] = 1;	// 좌표가 격자의 범위를 넘지 않기 때문에 1선분을 그림 (사실 점 찍는 것ㅋ)
			}
			//printf("order = %d\n", order);
		}	
	}
}

void Cnt_Print(void)
{
	int i, j;
	int cnt = 0;

	/* 각 점(Board[i][j])을 기준으로 1*1만큼 범위 내에 있는 점의 값(드래곤 커브면 1, 아니면 0)을 
	   더했을 때 4인 경우가 "크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 것"*/
	for (i = 0; i < 100; i++)
	{
		for (j = 0; j < 100; j++)
		{
			if ( Board[i][j] + Board[i + 1][j] + Board[i][j + 1] + Board[i + 1][j + 1] == 4 )
			{
				cnt++;
			}
		}
	}

	printf("%d\n", cnt);
}
#endif





// 20191003
// [BOJ. 15686] 치킨 배달
#if 0
#include <stdio.h>
#define ABS(r)	( (r) < 0 ? -(r) : (r) )
#define MAX	(55)
#define INF	(987654321)

typedef struct
{
	int y, x;
}NODE;
NODE Choose_List[15];
NODE List[15];
NODE Zero;

void Input(void);
void DFS(int L, int idx);
int Calc_Chick_ST(void);
void Print_List(void);
void Print(void);

int N, M;
int City[MAX][MAX];
int Min_Chick_ST;
int order;

int main(void)
{
	Input();
	DFS(1, 1);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	Zero.y = 0;		Zero.x = 0;
	Min_Chick_ST = INF;    	order = 1;
	scanf("%d %d", &N, &M);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &City[i][j]);
			if (City[i][j] == 2)
			{
				Choose_List[order].y = i;        Choose_List[order++].x = j;
			}
		}
	}
}

void DFS(int L, int idx)
{
	int i, r;

	if (L > M)
	{
		r = Calc_Chick_ST();
		if (Min_Chick_ST > r) Min_Chick_ST = r;
		return;
	}

	for (i = idx; i < order; i++)
	{
		List[L] = Choose_List[i];
		DFS(L + 1, i + 1);
		List[L] = Zero;
	}
}

int Calc_Chick_ST(void)
{
	int i, j, k;
	int min, check, sum = 0;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			if (City[i][j] == 1)
			{
				min = INF;
				for (k = 1; k <= M; k++)
				{
					check = ABS(List[k].y - i) + ABS(List[k].x - j);
					if (min > check) min = check;
				}
				sum += min;
			}
		}
	}
	return sum;
}

void Print(void)
{
	printf("%d\n", Min_Chick_ST);
}
#endif

// 광은님 ver로 다시 품!
#if 0
#include <stdio.h>
#define ABS(r)	( (r) < 0 ? -(r) : (r) )
// (r1 - r2)와 (c1 - c2)를 각각 ABS 매크로에 보내고, 그 결과값들을 합친 것이 치킨 거리!
#define MAX	(55)	// 범위는 넉넉하게 잡아야...
#define INF	(987654321)

typedef struct
{
	int y, x;
}NODE;
NODE Choose_List[15];	// 모든 치킨집의 좌표를 넣을 것
NODE House[MAX * MAX];

void Input(void);
void DFS(int L, int idx);
int Calc_Chick_ST(void);
void Print_List(void);
void Print(void);

int N, M;			// 도시의 크기, 폐업시키지 않을 치킨 집의 개수(선택 받은 치킨집!)
int City[MAX][MAX];	// 도시 좌표
int Min_Chick_ST;	// 치킨 거리의 최소값
int order;			// order - 1 = 총 치킨집의 수
int order_h;
int List[15];
int lcnt;

int main(void)
{
	Input();
	DFS(1, 1);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	Min_Chick_ST = INF;
	order = 1;					// 모든 치킨집의 좌표를 Choose_List에 저장해주기 위한 index(1 ~ order - 1)
	order_h = 1;
	scanf("%d %d", &N, &M);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &City[i][j]);
			if (City[i][j] == 2)	// 일단 모든 치킨 집의 좌표를 저장해줌
			{
				Choose_List[order].y = i;
				Choose_List[order++].x = j;
			}
			else if (City[i][j] == 1)
			{
				House[order_h].y = i;
				House[order_h++].x = j;
			}
		}
	}
}

void DFS(int L, int idx)	// (order - 1)개의 치킨집 중 M개의 치킨집! (조합)
{
	int i, r;

	if (L > M)
	{
		r = Calc_Chick_ST();   // M개의 치킨집을 살린 상태에서 각 집 ~ 가장 가까운 치킨집(치킨 거리)의 합 리턴
		if (Min_Chick_ST > r) Min_Chick_ST = r;	// 치킨 거리 최소인 경우 갱신
		return;
	}

	for (i = idx; i < order; i++)
	{
		List[L] = i;

		DFS(L + 1, i + 1);

		List[L] = 0;
	}
}

// 모든 치킨집 중에서 M개의 치킨 집을 고른 상태로 이 함수에 들어옴!
int Calc_Chick_ST(void)
{
	int i, j;
	int min;
	int check, sum = 0;

	for (i = 1; i < order_h; i++)
	{
		min = INF;
		for (j = 1; j <= M; j++)
		{
			check = ABS(House[i].y - Choose_List[List[j]].y)
				    + ABS(House[i].x - Choose_List[List[j]].x);
			if (min > check) min = check;
		}
		sum += min;
	}

	return sum;
}

void Print(void)
{
	printf("%d\n", Min_Chick_ST);
}
#endif






// 20191004
// [BOJ. 16236] 아기 상어
// 조금 수정 버전(4ms -> 0ms)
#if 0
#include <stdio.h>
#define MAX	(25)
#define INF     (987654321)

typedef struct
{
	int y, x;
	int size;
}SK;
SK Shark;

typedef struct
{
	int y, x;
}QUEUE;
QUEUE Q[MAX * MAX * 2];

void Input(void);
void InQ(int yy, int xx);
QUEUE * OutQ(void);
void Operation(void);
int BFS(int sy, int sx);
void Init_Visit_BFS(void);
void Print(void);

int N;
int Ocean[MAX][MAX];
int time;
int Visit[MAX][MAX];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int eat;
int Wp, Rp;
int min_y, min_x, min_time;

int main(void)
{
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, j, tmp;

	scanf("%d", &N);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &tmp);
			Ocean[i][j] = tmp;
			if (tmp == 9)
			{
				Ocean[i][j] = 0;
				Shark.y = i;    Shark.x = j;
				Shark.size = 2;
			}
		}
	}
}

void InQ(int yy, int xx)
{
	Q[Wp].y = yy;
	Q[Wp++].x = xx;
}

QUEUE * OutQ(void)
{
	return (&Q[Rp++]);
}

void Operation(void)
{
	int eat_fish;

	eat = 0;
	time = 0;
	for( ; ; )
	{
		Init_Visit_BFS();
		eat_fish = BFS(Shark.y, Shark.x);
		if(eat_fish == INF) break;
		Ocean[min_y][min_x] = 0;
		Shark.y = min_y;        Shark.x = min_x;
		time += eat_fish;
		if(++eat == Shark.size)
		{
			Shark.size++;
			eat = 0;
		}
	}
}

int BFS(int sy, int sx)
{
	QUEUE * out = (QUEUE *)0x0;
	int i;
	int ny, nx;
	int flag = 0;

	Wp = Rp = 0;
	InQ(sy, sx);
	Visit[sy][sx] = 0;

	while( Wp > Rp )
	{
		out = OutQ();
		sy = out->y;
		sx = out->x;
		for(i = 0; i < 4; i++)
		{
			ny = sy + dy[i];
			nx = sx + dx[i];
			if( ny < 1 || ny > N || nx < 1 || nx > N ) continue;      // N*N 공간 넘어가면 안됨
			if( Ocean[ny][nx] > Shark.size || Visit[ny][nx] != -1 ) continue; // 물고기 크기가 아기상어보다 크면 못 지나감
			// 그럼 일단 지나갈 수 있음
			Visit[ny][nx] = Visit[sy][sx] + 1;
			InQ(ny, nx);    // 크기가 같아도 지나갈 수는 있음!
			if( Ocean[ny][nx] != 0 && Ocean[ny][nx] < Shark.size )     // 아기상어가 먹을 수 있는 물고기다?
			{
				// ★★ 세부적인 조건 설계 단에서 꼭 구체적으로 다 만들어서 문제 진입하자!! ★★
				if( min_time > Visit[ny][nx] )    // 1) 일단 이동 거리(시간) 최소를 구함
				{
					min_y = ny;
					min_x = nx;
					min_time = Visit[ny][nx];
				}
				else if( min_time == Visit[ny][nx] )      // 거리(시간)이 같을 경우 위치 측정
				{
					if( min_y > ny )        // 2) 가장 위쪽?
					{
						min_y = ny;
						min_x = nx;
					}
					else if ( min_y == ny )  // 30 그것도 아니라면 가장 왼쪽?
					{
						if( min_x > nx ) min_x = nx;
					}
				}
			}
		}
	}

	return min_time;
}

void Init_Visit_BFS(void)
{
	int i, j;

	min_y = min_x = min_time = INF;
	for(i = 1; i <= N; i++)
	{
		for(j = 1; j <= N; j++)
		{
			Visit[i][j] = -1;
		}
	}
}

void Print(void)
{
	printf("%d\n", time);
}
#endif


#if 0
#include <stdio.h>
#define MAX	(25)
#define INF     (987654321)

typedef struct
{
	int y, x;
	int size;
}SK;
SK Shark;

typedef struct
{
	int y, x;
}QUEUE;
QUEUE Q[MAX * MAX * 2];

void Input(void);
void InQ(int yy, int xx);
QUEUE * OutQ(void);
void Operation(void);
int BFS(int sy, int sx);
void Init_Visit(void);
void Print(void);

int N;
int Ocean[MAX][MAX];
int time;
//int Size[10];
int Visit[MAX][MAX];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int eat;
int Wp, Rp;
int min_y, min_x, min_time;

int main(void)
{
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, j, tmp;

	scanf("%d", &N);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &tmp);
			Ocean[i][j] = tmp;
			//Size[tmp]++;
			if (tmp == 9)
			{
				Ocean[i][j] = 0;
				Shark.y = i;    Shark.x = j;
				Shark.size = 2;
			}
		}
	}
}

void InQ(int yy, int xx)
{
	Q[Wp].y = yy;
	Q[Wp++].x = xx;
}

QUEUE * OutQ(void)
{
	return (&Q[Rp++]);
}

void Operation(void)
{
	int eat_fish, cnt, flag = 1;
	int i;

	eat = 0;
	time = 0;
	while (flag)
	{
		Init_Visit();
		eat_fish = BFS(Shark.y, Shark.x);
		if (eat_fish == INF) break;
		//Size[ Ocean[min_y][min_x] ]--;
		Ocean[min_y][min_x] = 0;
		Shark.y = min_y;        Shark.x = min_x;
		time += eat_fish;
		if (++eat == Shark.size)
		{
			Shark.size++;
			eat = 0;
		}
		/*
		cnt = 0;
		for(i = 1; i < Shark.size; i++)
		{
		cnt += Size[i];
		}
		if(!cnt) flag = 0;
		*/
	}
}

int BFS(int sy, int sx)
{
	QUEUE * out = (QUEUE *)0x0;
	int i;
	int ny, nx;
	int flag = 0;

	Wp = Rp = 0;
	InQ(sy, sx);
	Visit[sy][sx] = 0;

	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;
		sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];
			nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > N) continue;      // N*N 공간 넘어가면 안됨
			if (Ocean[ny][nx] > Shark.size || Visit[ny][nx] != -1) continue; // 물고기 크기가 아기상어보다 크면 못 지나감
			// 그럼 일단 지나갈 수 있음
			Visit[ny][nx] = Visit[sy][sx] + 1;
			InQ(ny, nx);    // 크기가 같아도 지나갈 수는 있음!
			if (Ocean[ny][nx] != 0 && Ocean[ny][nx] < Shark.size)     // 아기상어가 먹을 수 있는 물고기다?
			{
				// ★★ 세부적인 조건 설계 단에서 꼭 구체적으로 다 만들어서 문제 진입하자!! ★★
				if (min_time > Visit[ny][nx])    // 1) 일단 이동 거리(시간) 최소를 구함
				{
					min_y = ny;
					min_x = nx;
					min_time = Visit[ny][nx];
				}
				else if (min_time == Visit[ny][nx])      // 거리(시간)이 같을 경우 위치 측정
				{
					if (min_y > ny)        // 2) 가장 위쪽?
					{
						min_y = ny;
						min_x = nx;
					}
					else if (min_y == ny)  // 30 그것도 아니라면 가장 왼쪽?
					{
						if (min_x > nx) min_x = nx;
					}
				}
			}
		}
	}

	return min_time;
}

void Init_Visit(void)
{
	int i, j;

	min_y = min_x = min_time = INF;
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			Visit[i][j] = -1;
		}
	}
}

void Print(void)
{
	printf("%d\n", time);
}
#endif






// 20191005
// [SWEA. 2117] [모의 SW 역량테스트] 홈 방범 서비스
#if 0
#include <stdio.h>
#define MAX     (25)
#define COST(i) ((i) * (i) + ((i) - 1) * ((i) - 1))

typedef struct
{
	int cost;
	int house_cnt;
}SERVICE;
SERVICE Service[MAX * 3];

typedef struct
{
	int y, x;
}NODE;
NODE Q[MAX * MAX * 2];

void Set_Data(void);
void Init(void);
void Input(void);
void Operation(void);
void InQ(int yy, int xx);
NODE * OutQ(void);
void FF_BFS(int sy, int sx);
int Calc_Max(void);
void Print_Struct(void);

int T;
int N, M;
int City[MAX][MAX];
int Wp, Rp;
int cnt_house;
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

int main(void)
{
	int i;

	scanf("%d", &T);
	Set_Data();
	for (i = 1; i <= T; i++)
	{
		Init();
		Input();
		Operation();
		printf("#%d %d\n", i, Calc_Max());
		Print_Struct();
	}

	return 0;
}

void Set_Data(void)
{
	int i;
	for (i = 1; i <= MAX * 2; i++) Service[i].cost = COST(i);
}

void Init(void)
{
	int i;
	for (i = 1; i <= N * 2 - 1; i++) Service[i].house_cnt = 0;
}

void Input(void)
{
	int i, j;

	cnt_house = 0;
	scanf("%d %d", &N, &M);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &City[i][j]);
			if (City[i][j]) cnt_house++;
		}
	}
}

void Operation(void)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			FF_BFS(i, j);
		}
	}
}

void InQ(int yy, int xx)
{
	Q[Wp].y = yy;
	Q[Wp++].x = xx;
}

NODE * OutQ(void)
{
	return &(Q[Rp++]);
}

void FF_BFS(int sy, int sx)
{
	NODE * out = (NODE *)0x0;
	int i, tmp, cnt = 0;
	int ny, nx;
	int Visit[MAX][MAX] = { 0 };      // Visit 배열 내의 값이 K, 즉 서비스 영역의 크기가 됨!
	int flag = 0;

	Wp = Rp = 0;
	InQ(sy, sx);
	Visit[sy][sx] = 1;
	if (City[sy][sx] == 1)
	{
		cnt++;
		Service[1].house_cnt = 1;
	}

	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;    sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];        nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > N || Visit[ny][nx]) continue;
			Visit[ny][nx] = Visit[sy][sx] + 1;
			InQ(ny, nx);
			if (City[ny][nx] == 1)
			{
				cnt++;
				tmp = Visit[ny][nx];
				if (Service[tmp].house_cnt < cnt)
				{
					Service[tmp].house_cnt = cnt;
				}
				if (cnt == cnt_house)
				{
					flag = 1;
					break;
				}
			}
		}
		if (flag) break;
	}
}

int Calc_Max(void)
{
	int i, max_house = 0;

	for (i = 1; i <= N * 2 - 1; i++)
	{
		if (Service[i].house_cnt * M - Service[i].cost >= 0)    // 손해 안 봄
		{
			if (max_house < Service[i].house_cnt)    // 서비스 영역 내 가장 많은 집의 수 갱신
			{
				max_house = Service[i].house_cnt;
			}
		}
	}

	return max_house;
}

void Print_Struct(void)
{
	int i;

	for (i = 0; i <= N * 2 - 1; i++)
	{
		printf("%5d%5d  ==> %d\n", Service[i].cost, Service[i].house_cnt, Service[i].house_cnt * M - Service[i].cost);
	}
}
#endif

// for문 + 배열 활용
#if 0
#include <stdio.h>

typedef struct st
{
	int r;
	int c;
}POS;
#define MAX (21)
void Set_Data(void);
int Operation(void);

int N, M;
int cost[30];
POS House[MAX*MAX];
int su_h;
int MAP[MAX][MAX];
int max_t;
int max;

int main(void)
{
	int t, T;

	scanf("%d", &T);

	for (t = 1; t < 30; t++)
	{
		cost[t] = t*t + (t - 1)*(t - 1);
	}

	for (t = 1; t <= T; t++)
	{
		Set_Data();

		printf("#%d %d\n", t, Operation());
	}
}

void Set_Data(void)
{
	int i, j;

	scanf("%d %d", &N, &M);

	su_h = 1;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &MAP[i][j]);
			if (MAP[i][j] == 1)
			{
				House[su_h].r = i;
				House[su_h++].c = j;
			}
		}
	}

	su_h--;

	for (i = 1; cost[i] <= su_h*M; i++);
	max_t = i - 1;

	max = 0;
}

int Operation(void)
{
	int i, j, u, x;
	int cover[50][MAX][MAX] = { 0 };
	int w, h;
	int distance;
	int cnt;

	for (i = 1; i <= N; i++) //마름모의 가운데점을 잡는다. 
	{
		for (j = 1; j <= N; j++)
		{
			for (u = 1; u <= su_h; u++)
			{
				h = i - House[u].r;
				if (h < 0) h *= -1;

				w = j - House[u].c;
				if (w < 0) w *= -1;

				distance = w + h;
				cover[distance][i][j]++;
				//가운뎃점을 i,j로 잡았을 때 각 거리 크기의 마름모가
				//몇 채를 잡을 수 있는지 
			}

			cnt = 0;
			for (x = 1; x <= max_t; x++) //마름모 크기
			{
				cnt += cover[x - 1][i][j]; //거리로 쟀으니 1 빼줘야함.
				if (cnt > max && cost[x] <= cnt*M) max = cnt;
			}
		}
	}

	return max;
}
#endif

// 20191009
// [SWEA. 2117] [모의 SW 역량테스트] 홈 방범 서비스  =>      다시 풀어보기!!
#if 0
#include <stdio.h>
#define MAX     (25)
#define COST(k) ( (k) * (k) + ((k) - 1) * ((k) - 1) )
#define ABS(a)  ( ((a) < 0) ? -(a) : (a) )

typedef struct
{
	int y, x;
}HOUSE;
HOUSE House[MAX * MAX];

void Input(void);
void Operation(void);

int T;
int N, M;
int City[MAX][MAX];
int house_cnt;
int Result_cnt;

int main(void)
{
	int t;

	scanf("%d", &T);
	for (t = 1; t <= T; t++)
	{
		Input();
		Operation();
		printf("#%d %d\n", t, Result_cnt);
	}


	return 0;
}

void Input(void)
{
	int i, j;

	house_cnt = 1;
	scanf("%d %d", &N, &M);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &City[i][j]);
			if (City[i][j])
			{
				House[house_cnt].y = i;
				House[house_cnt++].x = j;
			}
		}
	}
}

void Operation(void)
{
	int i, j, k, h;
	int cost, cnt;

	Result_cnt = 0;
	for (k = 1; k <= 2 * N - 1; k++)
	{
		cost = COST(k);
		printf("cost = %d\n", cost);
		for (i = 1; i <= N; i++)
		{
			for (j = 1; j <= N; j++)
			{
				cnt = 0;
				for (h = 1; h < house_cnt; h++)
				{
					if (ABS(House[h].y - i) + ABS(House[h].x - j) > k - 1) continue;
					cnt++;
				}
				if (cnt * M >= cost)
				{
					if (Result_cnt < cnt) Result_cnt = cnt;
				}
			}
		}
	}
}
#endif





// 20191006
// [BOJ. 13460] 구슬 탈출 2
#if 0
#include <stdio.h>
#define MAX     (15)

typedef struct
{
	int y, x;
}BEAD;
BEAD R, B;

void Input(void);
void DFS(int L, int ry, int rx, int by, int bx);
void Print(void);

int N, M;
char Board[MAX][MAX];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int end_flag;

int main(void)
{
	Input();
	DFS(1, R.y, R.x, B.y, B.x);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;
	char tmp[15];

	end_flag = 11;
	scanf("%d %d", &N, &M);
	for (i = 0; i < N; i++)
	{
		scanf("%s", tmp);
		for (j = 0; j < M; j++)
		{
			Board[i][j] = tmp[j];
			if (tmp[j] == 'R')
			{
				R.y = i;        R.x = j;
			}
			else if (tmp[j] == 'B')
			{
				B.y = i;        B.x = j;
			}
		}
	}
}

void DFS(int L, int ry, int rx, int by, int bx)
{
	int i, jr, jb;
	int nry, nrx, nby, nbx;

	if (L > 10) return;

	for (i = 0; i < 4; i++)  // 사방으로 갈 수 있음
	{
		// DFS 처음 시작할 때, 그리고 DFS 후에 백트래킹으로 돌아왔을 때는 움직이기 전의 초기 위치로 와있어야 함
		nry = ry;       nrx = rx;
		nby = by;       nbx = bx;
		// 우선 빨간 구슬 먼저 이동시킬 것
		for (jr = 0;; jr++)
		{
			// 앞칸이 벽이라면 그 전에 멈춰야 하고, 지금 있는 칸이 구멍이라면 멈춰야 함
			if (Board[nry + dy[i]][nrx + dx[i]] == '#' || Board[nry][nrx] == 'O') break;
			// 그렇지 않으면 그 방향으로 갈 수 있음
			nry += dy[i];   nrx += dx[i];
		}
		// 그 다음으로 파란 구슬을 이동시킬 것
		for (jb = 0;; jb++)
		{
			// 앞칸이 벽이라면 그 전에 멈춰야 하고, 지금 있는 칸이 구멍이라면 멈춰야 함
			if (Board[nby + dy[i]][nbx + dx[i]] == '#' || Board[nby][nbx] == 'O') break;
			// 그렇지 않으면 그 방향으로 갈 수 있음
			nby += dy[i];   nbx += dx[i];
		}
		// 각 구슬을 독립적으로 생각하고 일단 움직인 후에,,, 보니까 두 구슬이 같은 위치에 와있다? (이런 경우는 있을 수 없으므로 조작을 가해줘야 함!)
		if (nry == nby && nrx == nbx)
		{
			// 일단 둘 다 구멍에 빠졌다면, 실패인 경우이므로 "이 방향으로 보내면 안돼..!!" 그렇기 때문에 다른 방향으로 보내줘야 함
			if (Board[nby][nbx] == 'O') continue;
			// 두 구슬이 구멍에 같이 들어가는 경우가 아니라 벽 때문에 막힌 것임. 근데 같은 곳에 있음(있을 수 없는 경우)
			if (jr < jb)     // 파란 구슬이 더 멀리서 왔다면, 한 칸 뒤로 물러줘야
			{
				nby -= dy[i];   nbx -= dx[i];
			}
			else    // 빨간 구슬이 더 멀리서 왔다면, 한 칸 뒤로 물러줘야
			{
				nry -= dy[i];   nrx -= dx[i];
			}
		}
		// 그런 후에도 빨간 구슬이 구멍에 있다면, 탈출한 케이스이므로 기록을 해주어야 함. 그런데 "최소 횟수"로 빼줘야 하므로 최소값을 갱신하도록 함
		if (Board[nry][nrx] == 'O')
		{
			if (end_flag > L) end_flag = L;
		}
		// 이동 후에 빨간 구슬과 파란 구슬이 같은 위치에 있지 않았고, 파란 구슬만 구멍에 빠졌다? 그러면 다른 방향으로 부내줘야 하므로 continue를 시켜 4방 설정해주는 for문으로 가야 함!
		else if (Board[nby][nbx] == 'O') continue;

		DFS(L + 1, nry, nrx, nby, nbx);
	}
}

void Print(void)
{
	printf("%d\n", ((end_flag == 11) ? -1 : end_flag));
}
#endif




// 20191006
// [BOJ. 14500] 테트로미노
#if 0
#include <stdio.h>
#define MAX     (510)

void Input(void);
void Operation(void);
int Get_Max(int yy, int xx);
void Print(void);

int N, M;
int Paper[MAX][MAX];
int Max_sum;

int main(void)
{
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	Max_sum = 0;
	scanf("%d %d", &N, &M);
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < M; j++)
		{
			scanf("%d", &Paper[i][j]);
		}
	}
}

void Operation(void)
{
	int i, j, r;

	for (i = 0; i < N; i++)
	{
		for (j = 0; j < M; j++)
		{
			r = Get_Max(i, j);
			if (Max_sum < r) Max_sum = r;
		}
	}
}

int Get_Max(int yy, int xx)
{
	int max = 0;
	int results[19] = { 0 };
	int i;

	if (N - yy >= 2 && M - xx >= 2)
	{
		results[0] = Paper[yy][xx] + Paper[yy][xx + 1] + Paper[yy + 1][xx] + Paper[yy + 1][xx + 1];     // 2*2 블럭
	}
	if (N - yy >= 2 && M - xx >= 3)
	{
		results[1] = Paper[yy][xx] + Paper[yy + 1][xx] + Paper[yy + 1][xx + 1] + Paper[yy + 1][xx + 2];
		results[2] = Paper[yy][xx + 2] + Paper[yy + 1][xx] + Paper[yy + 1][xx + 1] + Paper[yy + 1][xx + 2];
		results[3] = Paper[yy][xx] + Paper[yy + 1][xx] + Paper[yy][xx + 1] + Paper[yy][xx + 2];
		results[4] = Paper[yy][xx] + Paper[yy + 1][xx + 2] + Paper[yy][xx + 1] + Paper[yy][xx + 2];
		results[5] = Paper[yy][xx] + Paper[yy][xx + 1] + Paper[yy + 1][xx + 1] + Paper[yy + 1][xx + 2];
		results[6] = Paper[yy + 1][xx] + Paper[yy + 1][xx + 1] + Paper[yy][xx + 1] + Paper[yy][xx + 2];
		results[7] = Paper[yy + 1][xx] + Paper[yy + 1][xx + 1] + Paper[yy + 1][xx + 2] + Paper[yy][xx + 1];
		results[8] = Paper[yy][xx] + Paper[yy][xx + 1] + Paper[yy][xx + 2] + Paper[yy + 1][xx + 1];
	}
	if (N - yy >= 3 && M - xx >= 2)
	{
		results[9] = Paper[yy][xx] + Paper[yy + 1][xx] + Paper[yy + 2][xx] + Paper[yy + 2][xx + 1];
		results[10] = Paper[yy][xx + 1] + Paper[yy + 1][xx + 1] + Paper[yy + 2][xx + 1] + Paper[yy + 2][xx];
		results[11] = Paper[yy][xx] + Paper[yy + 1][xx] + Paper[yy + 2][xx] + Paper[yy][xx + 1];
		results[12] = Paper[yy][xx + 1] + Paper[yy + 1][xx + 1] + Paper[yy + 2][xx + 1] + Paper[yy][xx];
		results[13] = Paper[yy][xx] + Paper[yy + 1][xx] + Paper[yy + 1][xx + 1] + Paper[yy + 2][xx + 1];
		results[14] = Paper[yy + 1][xx] + Paper[yy + 2][xx] + Paper[yy + 1][xx + 1] + Paper[yy][xx + 1];
		results[15] = Paper[yy][xx] + Paper[yy + 1][xx] + Paper[yy + 2][xx] + Paper[yy + 1][xx + 1];
		results[16] = Paper[yy][xx + 1] + Paper[yy + 1][xx + 1] + Paper[yy + 2][xx + 1] + Paper[yy + 1][xx];
	}
	if (N - yy >= 1 && M - xx >= 4)
	{
		results[17] = Paper[yy][xx] + Paper[yy][xx + 1] + Paper[yy][xx + 2] + Paper[yy][xx + 3];
	}
	if (N - yy >= 4 && M - xx >= 1)
	{
		results[18] = Paper[yy][xx] + Paper[yy + 1][xx] + Paper[yy + 2][xx] + Paper[yy + 3][xx];
	}

	for (i = 0; i < 19; i++)
	{
		if (max < results[i]) max = results[i];
	}

	return max;
}

void Print(void)
{
	printf("%d\n", Max_sum);
}
#endif




// 20191006
// [BOJ. 2479] 경로 찾기 (SPJ.)
#if 0
#include <stdio.h>
#define NAX (1010)
#define KAX (35)

void Input(void);
int Get_Distance(char *p, char *q);
int BFS(int ss);
void Recursive_Print(int num);

int N;  // 이진코드 수
int K;  // 이진코드 길이
char Code[NAX][KAX];
int Visit[NAX];
int Path[NAX];
int Queue[NAX * 10];
int s, e;
int Wp, Rp;

int main(void)
{
	int r;

	Input();
	r = BFS(s);
	if (r) Recursive_Print(e);
	else printf("-1\n");

	return 0;
}

void Input(void)
{
	int i;

	scanf("%d %d", &N, &K);
	for (i = 1; i <= N; i++)
	{
		scanf("%s", Code[i]);
	}
	scanf("%d %d", &s, &e);
}

int Get_Distance(char *p, char *q)
{
	int i, cnt = 0;

	for (i = 0; i < K; i++)
	{
		if ((*p - '0') ^ (*q - '0')) cnt++;
		p++; q++;
	}

	return cnt;
}

int BFS(int ss)
{
	int i;
	int out;

	Queue[Wp++] = ss;
	Visit[ss] = 1;
	Path[ss] = 0;

	while (Wp > Rp)
	{
		out = Queue[Rp++];
		for (i = 1; i <= N; i++)
		{
			if (Visit[i]) continue;
			if (Get_Distance(Code[out], Code[i]) == 1)
			{
				Queue[Wp++] = i;
				Visit[i] = 1;
				Path[i] = out;
				if (i == e) return 1;
			}
		}
	}

	return 0;
}

void Recursive_Print(int num)
{
	if (num == 0) return;

	Recursive_Print(Path[num]);
	printf("%d ", num);
}
#endif




// 20191007
// [BOJ. 17471] 게리맨더링
#if 0
#include <stdio.h>
#define MAX	(14)
#define INF	(987654321)
#define ABS(a)	( ((a) < 0) ? -(a) : (a) )

void Input(void);
void DFS(int L, int s_idx);
int BFS(int flag);
void Print(void);

int N;
int population[MAX];
int Injub[MAX][MAX];
int Visit[MAX];
int Q[MAX];
int Min_Diff;
int sumA, sumB;
int Wp, Rp;
int cnt;

int main(void)
{
	Input();
	DFS(1, 1);
	Print();

	return 0;
}

void Input(void)
{
	int i, tmp, ttmp;

	Min_Diff = INF;         cnt = 0;
	scanf("%d", &N);
	for (i = 1; i <= N; i++) scanf("%d", &population[i]);
	for (i = 1; i <= N; i++)
	{
		scanf("%d", &tmp);
		Injub[i][0] = tmp;
		while (tmp--)
		{
			scanf("%d", &ttmp);
			Injub[i][ttmp] = Injub[ttmp][i] = 1;
		}
	}
}

void DFS(int L, int s_idx)
{
	int i, j, check;

	if (Min_Diff == 0) return;
	if (L > N) return;
	if (L > 1)
	{
		//for(int k = 1; k <= N; k++) printf("%d ", Visit[k]);  printf("\n");
		if ( BFS(1) && BFS(0) )
		{
			sumA = sumB = 0;
			for (j = 1; j <= N; j++)
			{
				if (Visit[j]) sumA += population[j];
				else sumB += population[j];
			}
			check = ABS(sumA - sumB);
			if (Min_Diff > check) Min_Diff = check;
		}
	}

	for (i = s_idx; i <= N; i++)
	{
		//if (Visit[i]) continue;
		Visit[i] = 1;   cnt++;
		DFS(L + 1, i + 1);
		Visit[i] = 0;   cnt--;
	}
}

int BFS(int flag)
{
	int Visit2[MAX] = { 0 };
	int count;
	int i, s, out;

	Wp = Rp = 0;
	for (i = 1; i <= N; i++)
	{
		if (Visit[i] == flag)
		{
			s = i;
			break;
		}
	}

	Visit2[s] = 1;
	Q[Wp++] = s;
	count = 1;
	while (Wp > Rp)
	{
		out = Q[Rp++];
		for (i = 1; i <= N; i++)
		{
			//    Visit은 조합용   Visit2는 방문표시용     Injub은 인접 배열
			if (Visit[i] == flag && Visit2[i] == 0 && Injub[out][i] == 1)
			{
				Visit2[i] = 1;
				Q[Wp++] = i;
				count++;
			}
		}
	}

	if (flag && count == cnt) return 1;
	if (!flag && count == N - cnt) return 1;
	return 0;
}

void Print(void)
{
	/*
	for (int i = 0; i <= N; i++)
	{
		for (int j = 0; j <= N; j++)
		{
			printf("%d ", Injub[i][j]);
		}
		printf("\n");
	}
	printf("\n");
	*/

	printf("%d\n", ((Min_Diff == INF) ? -1 : Min_Diff));
}
#endif

// ★규홍님 ver.
#if 0
#include<stdio.h>

int N;

int a[15][15];	// 도시 각 구역 인접
int ingu[15];	// 각 구억의 인구수
int list[15];	// DFS에서 조합 받아주기 위함
int chk1[15];	// 선거구 A
int chk2[15];	// 선거구 B

void input(void);
void DFS(int L, int prev);	// 조합 만들어주며 재귀. 조합 구성요소의 개수가 1 ~ N - 1인 경우에 한하여 그 조합 / 나머지로 선거구 나눠줌
int check(void);	
void printlist(int L);
void init_chk(int L);
void printchk(void);

int total_sum;
int min = 0x7fffffff;

int main()
{
	input();

	DFS(1, 1);

	if (min != 0x7fffffff) printf("%d", min);
	else printf("-1");

	return 0;
}

void printchk(void)
{
	int i;

	printf("chk1 : ");

	for (i = 1; i <= N; i++)
		printf("%d ", chk1[i]);
	printf("\n");

	printf("chk2 : ");
	for (i = 1; i <= N; i++)
		printf("%d ", chk2[i]);
	printf("\n");
}

int check1(int L)
{
	int i;

	chk1[L] = 1;
	for (i = 1; i <= N; i++)
	{	// 인접이 되어 있지 않거나, 그 조합의 멤버가 아니라면(갈 수 없는 곳이라 생각!) 컨티뉴
		if ( !a[L][i] || chk1[i] ) continue;
		check1(i);
	}
}

int check2(int L)
{
	int i;

	chk2[L] = 1;
	for (i = 1; i <= N; i++)
	{	// 인접이 되어 있지 않거나, 그 조합의 멤버가 아니라면(갈 수 없는 곳이라 생각!) 컨티뉴
		if ( !a[L][i] || chk2[i] ) continue;
		check2(i);
	}
}

void printlist(int L)
{
	int i;
	for (i = 1; i < L; i++)
		printf("%d ", list[i]);
	printf("\n");
}

void init_chk(int L)
{
	int i;

	for (i = 1; i <= N; i++)
	{
		chk1[i] = 0;
		chk2[i] = 0;
	}

	// DFS로 만들어진 조합(in List 배열)을 chk2 배열에서는 반전시켜 저장함
	for (i = 1; i < L; i++)
	{
		chk2[list[i]] = 1;
	}

	// DFS로 만들어진 조합(in List 배열)을 chk1 배열에 저장함
	for (i = 1; i <= N; i++)
	{
		if (chk2[i] == 0) chk1[i] = 1;
	}


}

int chk_geri(int L)
{
	int i, j;
	int sum = 0;

	for (i = 1; i <= N; i++)
	{	// 선거구 A, B의 구역들이 각각 잘 인접이 되어 있나 확인을 해보는데
		// 인접하면 chk1, chk2 배열에 1로 찰 것
		// chk1, 2배열에 0이 있다면, 인접하지 않은 것이므로 잘못된 것!
		if (!chk1[i] || !chk2[i]) return -1;
	}

	for (i = 1; i < L; i++)
		sum += ingu[list[i]];

	return abs(total_sum - 2 * sum);

}

void DFS(int L, int prev)
{
	int i, tmp;

	if (L > 1)
	{
		//printlist(L);
		init_chk(L);

		//printchk();

		for (i = 1; i <= N; i++)
		{
			if (chk1[i] == 1)
			{
				check2(i);
				break;
			}
		}

		check1(list[1]);

		//printchk();
		tmp = chk_geri(L);
		//printf("인구값 비교 %d\n", tmp);

		if (tmp != -1 && min > tmp)
		{
			//printlist(L);
			//printf("인구값 비교 %d\n", tmp);
			min = tmp;
		}
	}

	if (L >= N)
	{
		return;
	}

	for (i = prev; i <= N; i++)
	{
		list[L] = i;
		DFS(L + 1, i + 1);
		list[L] = 0;
	}
}

void input(void)
{
	int i, j;
	int in_num;
	int temp;

	scanf("%d", &N);

	for (i = 1; i <= N; i++)
	{
		scanf("%d", &ingu[i]);
		total_sum += ingu[i];
	}

	for (i = 1; i <= N; i++)
	{
		scanf("%d", &in_num);

		for (j = 0; j < in_num; j++)
		{
			scanf("%d", &temp);
			a[i][temp] = 1;
		}
	}
}


#endif

// ★은애님 ver.★
#if 0
#include <stdio.h>

#define INF 987654321
#define MAX (10 + 2)
#define ABS(x) ((x < 0) ? (-(x)) : (x))

void SetData(void);
void DFS(int d, int fir, int sec);
int Check(void);

int N;
int ans = INF;
int p[MAX];			// 각 구역의 인구수
int f[MAX], s[MAX];	// f : 첫 번째 선거구의 구역 체크 / s : 두 번째 선거구의 구역 체크
int a[MAX][MAX];	// 인접 배열
int Q[MAX * MAX];
int wp, rp;

int main(void)
{
	SetData();

	DFS(1, 0, 0);

	if (ans == INF) ans = -1;
	printf("%d\n", ans);

	return 0;
}

void SetData(void)
{
	int i, j;
	int su, t;

	scanf("%d", &N);

	for (i = 1; i <= N; i++)
	{
		scanf("%d", &p[i]);
	}

	for (i = 1; i <= N; i++)
	{
		scanf("%d", &su);
		for (j = 1; j <= su; j++)
		{
			scanf("%d", &t);
			a[i][t] = 1;
		}
	}
}

void DFS(int d, int fir, int sec) // 선거구, 구역1 인구, 구역2 인구
{
	if (d > N) // N개 다 고름
	{
		int dif = ABS(fir - sec);
		if (dif >= ans) return;

		// 각 선거구에 구역이 하나도 없거나 몰빵되는 경우를 그냥 이 조건으로 걸러줌
		if (fir == 0 || sec == 0) return;
		if (Check()) return;

		ans = dif;
		return;
	}

	f[d] = 1;
	DFS(d + 1, fir + p[d], sec);
	f[d] = 0;

	s[d] = 1;
	DFS(d + 1, fir, sec + p[d]);
	s[d] = 0;
}

int Check(void)	// BFS로 인접 방문하는 함수
{
	int v[MAX] = { 0 }; // 꼼수 쓰지 말고 그냥 방문 배열 사용할 것
	int i, out, st;

	st = wp = rp = 0; // 첫번째 선거구 검사
	while (!f[st]) st++; // 첫번째 노드 정하고, 여기서부터 퍼져나감

	v[st] = 1; // 방문표시
	Q[wp++] = st;

	while (wp > rp)
	{
		out = Q[rp++];
		for (i = 1; i <= N; i++)
		{
			if (f[i] && !v[i] && a[out][i]) // 첫번째 구역에 속하며, 노드가 연결되어 있으면
			{
				Q[wp++] = i;
				v[i] = 1; // 방문표시
			}
		}
	}

	for (i = 1; i <= N; i++)
	{
		if (f[i] && !v[i]) return 1; // 방문 못한 곳 있음 
	}

	st = wp = rp = 0; // 두번째 선거구 검사
	while (!s[st]) st++;

	v[st] = 1;
	Q[wp++] = st;

	while (wp > rp)
	{
		out = Q[rp++];
		for (i = 1; i <= N; i++)
		{
			if (s[i] && !v[i] && a[out][i])
			{
				Q[wp++] = i;
				v[i] = 1;
			}
		}
	}

	for (i = 1; i <= N; i++)
	{
		if (s[i] && !v[i]) return 1;
	}

	return 0;
}
#endif





// 20191009
// [BOJ. 17143] 낚시왕
#if 0
#include <stdio.h>
#define MAX     (110)
#define INF     (987654321)

typedef struct
{
	int y, x;
	int spd;
	int dir;
	int size;
}SHARK;
SHARK Shark[MAX * MAX];

void Input(void);
void Operation(void);
void Move_Eat_Shark(void);
void Print(void);
void Draw_Map(void);

int R, C, M;
int Map[MAX][MAX];
int dy[5] = { 0, -1, 1, 0, 0 };
int dx[5] = { 0, 0, 0, 1, -1 };
int dd[5] = { 0, 2, 1, 4, 3 };
int size_sum;

int main(void)
{
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i;
	int yy, xx, s, d, z;

	scanf("%d %d %d", &R, &C, &M);
	for (i = 1; i <= M; i++)
	{
		scanf("%d %d %d %d %d", &yy, &xx, &s, &d, &z);
		Shark[i].y = yy;        Shark[i].x = xx;
		Shark[i].spd = s;       Shark[i].dir = d;       Shark[i].size = z;
		Map[yy][xx] = i;
	}
}

void Operation(void)
{
	int Fisher, i, min_y, die_idx;

	size_sum = 0;
	for (Fisher = 1; Fisher <= C + 1; Fisher++)      // 1) 낚시왕의 이동
	{
		min_y = INF;    die_idx = 0;
		for (i = 1; i <= M; i++)					 // 2) 상어 잡이
		{
			if (Shark[i].size <= 0) continue;		// 상어가 죽으면 Size를 0으로 만들어 줌으로써 확인 가능
			if (Shark[i].x == Fisher)
			{
				if (min_y > Shark[i].y)
				{
					min_y = Shark[i].y;				// 가장 가까운지 확인하는 기준을 잡기 위해 기억해둠
					die_idx = i;					// 가장 가까운 상어를 잡으면 그 idx 기억해둠
				}
			}
		}
		size_sum += Shark[die_idx].size;			// 상어 잡고 그 사이즈의 합 구함	
		Map[Shark[die_idx].y][Shark[die_idx].x] = 0;// 상어는 잡혔으니 Map에서 지워줌
		Shark[die_idx].size = 0;					// 상어는 잡혔으니 Size 0이 됨

		Move_Eat_Shark();						   // 3) 상어의 이동과 사냥

		//Draw_Map();
	}
}

void Move_Eat_Shark(void)
{
	int i, j, dist, dir;
	int sy, sx;

	for (i = 1; i <= M; i++) // 3-1) 상어의 이동
	{
		if (Shark[i].size <= 0) continue;
		sy = Shark[i].y;        sx = Shark[i].x;
		Map[sy][sx] = 0;
		dir = Shark[i].dir;

		// ★ 만약 dist(가야할 거리)가 1000으로 주어진다면? for문으로 다 돌면 너무 비효율적.. ★
		// 그렇기 때문에 다시 처음 상태로 돌아올 때까지의 거리를 구해주고, 그것으로 주어진 가야할 거리를 Mod 해줌!
		// 그럼 최대 가는 거리가 확 줄어듦!
		if (dir <= 2) dist = Shark[i].spd % (2 * (R - 1));      // 상하로 왔다갔다
		else dist = Shark[i].spd % (2 * (C - 1));               // 좌우로 왔다갔다

		for (j = 1; j <= dist; j++)
		{
			if (sy + dy[dir] < 1 || sy + dy[dir] > R || sx + dx[dir] < 1 || sx + dx[dir] > C)
			{
				dir = dd[dir];
			}
			sy += dy[dir];         sx += dx[dir];
		}
		Shark[i].y = sy;        Shark[i].x = sx;
		Shark[i].dir = dir;
	}

	for (i = 1; i <= M; i++) // 3-2) 상어가 상어 먹음
	{
		if (Shark[i].size <= 0) continue;
		sy = Shark[i].y;        sx = Shark[i].x;
		if (Map[sy][sx])
		{
			if (Shark[i].size > Shark[Map[sy][sx]].size)
			{
				Shark[Map[sy][sx]].size = 0;
				Map[sy][sx] = i;
			}
			else Shark[i].size = 0;
		}
		else Map[sy][sx] = i;
	}
}

void Print(void) { printf("%d\n", size_sum); }

void Draw_Map(void)
{
	int i, j;

	for (i = 1; i <= R; i++)
	{
		for (j = 1; j <= C; j++)
		{
			printf("%2d ", Map[i][j]);
		}
		printf("\n");
	}
	printf("\n\n");
}
#endif




// 20191009
// [BOJ. 17086] 아기 상어 2
#if 0
#include <stdio.h>
#define MAX     (55)
#define INF     (987654321)

typedef struct
{
	int y, x;
}NODE;
NODE Shark[MAX * MAX];
NODE Q[MAX * MAX];

void Input(void);
void Init_Visit(void);
void Operation(void);
void InQ(int yy, int xx);
NODE * OutQ(void);
void BFS_Get_Distance(int sy, int sx);
int Get_Safety_Dist(void);
void Print(void);
void Print_Map(void);
void Print_Visit(void);

int N, M;
int Map[MAX][MAX];
int Visit[MAX][MAX];
int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };
int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };
int Shark_cnt;
int Wp, Rp;

int main(void)
{
	Input();
	Init_Visit();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	Shark_cnt = 1;
	scanf("%d %d", &N, &M);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			scanf("%d", &Map[i][j]);
			if (Map[i][j])
			{
				Shark[Shark_cnt].y = i;
				Shark[Shark_cnt++].x = j;
			}
		}
	}
}

void Init_Visit(void)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			Visit[i][j] = INF;
		}
	}
}

void Operation(void)
{
	int i;
	int sy, sx;

	for (i = 1; i < Shark_cnt; i++)
	{
		sy = Shark[i].y;        sx = Shark[i].x;
		BFS_Get_Distance(sy, sx);
		//Print_Visit();
	}
}

void InQ(int yy, int xx)
{
	Q[Wp].y = yy;
	Q[Wp++].x = xx;
}

NODE * OutQ(void)
{
	return &(Q[Rp++]);
}

void BFS_Get_Distance(int sy, int sx)
{
	NODE * out = (NODE *)0x0;
	int i, ny, nx, check, dist = 0;

	Wp = Rp = 0;
	InQ(sy, sx);
	Visit[sy][sx] = 0;
	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;    sx = out->x;
		for (i = 0; i < 8; i++)
		{
			ny = sy + dy[i];        nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > M) continue;
			check = Visit[sy][sx] + 1;
			if (!Map[ny][nx] && Visit[ny][nx] > check)
			{
				Visit[ny][nx] = check;
				InQ(ny, nx);
			}
		}
	}
}

int Get_Safety_Dist(void)
{
	int i, j, dist = 0;;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			if (dist < Visit[i][j]) dist = Visit[i][j];
		}
	}
	return dist;
}

void Print(void)
{
	printf("%d\n", Get_Safety_Dist());
}

void Print_Map(void)
{
	int i, j;

	printf("\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			printf("%d ", Map[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}

void Print_Visit(void)
{
	int i, j;

	printf("\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			printf("%d ", Visit[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}
#endif




// 20191009
// [BOJ. 17472] 다리 만들기2
#if 0
#include <stdio.h>
#define MAX     (15)
#define INF     (21)

typedef struct
{
	int y, x;
}NODE;
NODE Q[MAX * MAX * 2];

void Input(void);
void InQ(int yy, int xx);
NODE * OutQ(void);
void Island_Numbering(void);
void BFS_Island(int sy, int sx, int num);
void Prepare_Bridge(void);
void BFS_Constructing(int num);
void Construct_Bridge(void);
void DFS_Bridge_Sum(int L, int s, int sum);
void Init_Chk(void);
void Print(void);

void Print_Island(void);
void Print_chk(void);
void Print_Bridge(void);

int N, M;
int Map[MAX][MAX];
int Island[MAX][MAX];
int island_cnt;
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int Bridge[7][7];
int chk[7][7];
int Bridge_sum;
int Wp, Rp;

int main(void)
{
	freopen("in.txt", "r", stdin);
	Input();
	Island_Numbering();
	Prepare_Bridge();
	Construct_Bridge();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d %d", &N, &M);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			scanf("%d", &Map[i][j]);
		}
	}
}

void Island_Numbering(void)
{
	int i, j;

	island_cnt = 1;
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			if (Map[i][j] && !Island[i][j])
			{
				BFS_Island(i, j, island_cnt);
				island_cnt++;
			}
		}
	}
}

void InQ(int yy, int xx)
{
	Q[Wp].y = yy;
	Q[Wp++].x = xx;
}

NODE * OutQ(void)
{
	return &(Q[Rp++]);
}

void BFS_Island(int sy, int sx, int num)
{
	NODE * out = (NODE *)0x0;
	int i, ny, nx;

	Wp = Rp = 0;
	InQ(sy, sx);
	Island[sy][sx] = num;
	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;    sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];        nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > M) continue;
			if (Map[ny][nx] && !Island[ny][nx])
			{
				Island[ny][nx] = num;
				InQ(ny, nx);
			}
		}
	}
}

void Prepare_Bridge(void)
{
	int i;

	for (i = 1; i < island_cnt; i++)
	{
		BFS_Constructing(i);
	}
}

void BFS_Constructing(int num)
{
	int i, j;
	NODE * out = (NODE *)0x0;
	int sy, sx, ny, nx, dist;
	int out_flag = 0;

	Wp = Rp = 0;    // Q 크기 괜찮나?
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			if (Island[i][j] == num) InQ(i, j);
		}
	}

	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;    sx = out->x;
		for (i = 0; i < 4; i++)
		{
			out_flag = 0;
			ny = sy + dy[i];        nx = sx + dx[i];
			for (dist = 1;; dist++)
			{
				if (ny < 1 || ny > N || nx < 1 || nx > M)
				{
					out_flag = 1;
					break;
				}
				if (Island[ny][nx]) break;
				ny += dy[i];    nx += dx[i];
			}
			if (out_flag || Island[ny][nx] == num) continue;
			if (dist >= 3)
			{
				Bridge[num][Island[ny][nx]] = Bridge[Island[ny][nx]][num] = dist - 1;
			}
		}
	}
}

void Construct_Bridge(void)
{
	int i;

	Bridge_sum = INF;
	for(i = 1; i < island_cnt; i++)
	{
		Init_Chk();
		//chk[i] = 0;
		DFS_Bridge_Sum(1, i, 0);
		//chk[i] = 0;
	}
}

void DFS_Bridge_Sum(int L, int s, int sum)
{
	int i, check;

	printf("Depth = %d, start = %d, sum = %d\n", L, s, sum);
	if (L >= island_cnt - 1)
	{
		if (Bridge_sum > sum) Bridge_sum = sum;
		return;
	}

	for (i = 1; i < island_cnt; i++)
	{
		check = Bridge[s][i];
		if ( !Bridge[s][i] || chk[s][i] <= check) continue;
		chk[s][i] = chk[i][s] = check;
		DFS_Bridge_Sum(L + 1, i, sum + Bridge[s][i]);
		//chk[s][i] = chk[i][s] = 0;
	}
}

/*
void DFS_Bridge_Sum(int L, int s, int sum)
{
	int i, check, j;

	printf("Depth = %d, start = %d, sum = %d\n", L, s, sum);
	if(L >= island_cnt - 1)
	{
		//for (j = 1; j < island_cnt; j++) if (chk[j] == INF) return;
		Print_chk();
		if(Bridge_sum > sum) Bridge_sum = sum;
		return;
	}

	for(i = 1; i < island_cnt; i++)
	{
		check = Bridge[s][i];
		if ( !Bridge[s][i] || chk[i] <= check ) continue;
		chk[i] = check;
		DFS_Bridge_Sum(L + 1, i, sum + check);
		//chk[i] = 0;
	}
}
*/


void Init_Chk(void)
{
	int i, j;

	for (i = 1; i < island_cnt; i++)
		for (j = 1; j < island_cnt; j++)
			chk[i][j] = INF;
}


void Print(void)
{
	Print_Island();
	Print_Bridge();
	printf("%d\n", ((Bridge_sum == INF) ? -1 : Bridge_sum));
}

void Print_Island(void)
{
	int i, j;

	printf("\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			printf("%d ", Island[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}

void Print_chk(void)
{
	int i;

	printf("[chk] ");
	for (i = 1; i < island_cnt; i++) printf("%2d ", chk[i]);
	printf("\n");
}

void Print_Bridge(void)
{
	int i, j;

	printf("\n");
	for (i = 1; i < island_cnt; i++)
	{
		for (j = 1; j < island_cnt; j++)
		{
			printf("%2d ", Bridge[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}
#endif




// 20191009
// [BOJ. 2146] 다리 만들기
#if 0
#include <stdio.h>
#define MAX     (110)
#define INF     (987654321)

typedef struct
{
	int y, x;
}NODE;
NODE Q[MAX * MAX * 2];

void Input(void);
void Island_Numbering(void);
void BFS_Island(int sy, int sx, int num);
void InQ(int yy, int xx);
NODE * OutQ(void);
void Init_Visit(void);
void Construct_Bridge(void);
int FF_BFS_Bridge(int comp);
void Print(void);
void Print_Visit(void);

int N;
int Map[MAX][MAX];
int Island[MAX][MAX];
int island_cnt;
int Visit[MAX][MAX];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int min_Bridge;
int Wp, Rp;

int main(void)
{
	freopen("in.txt", "r", stdin);
	Input();
	Island_Numbering();
	Construct_Bridge();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d", &N);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &Map[i][j]);
		}
	}
}

void Init_Visit(void)
{
	int i, j;

	for (i = 1; i <= N; i++) for (j = 1; j <= N; j++) Visit[i][j] = INF;
}

void Island_Numbering(void)
{
	int i, j;

	island_cnt = 1;
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			if (Map[i][j] && !Island[i][j])
			{
				BFS_Island(i, j, island_cnt);
				island_cnt++;
			}
		}
	}

	/*
	printf("Print_Island\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			//if (!Island[i][j]) continue;
			printf("%d ", Island[i][j]);
		}
		printf("\n");
	}
	printf("\n");
	*/
}

void BFS_Island(int sy, int sx, int num)
{
	NODE * out = (NODE *)0x0;
	int i;
	int ny, nx;

	Wp = Rp = 0;
	Island[sy][sx] = num;
	InQ(sy, sx);
	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;    sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];        nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > N) continue;
			if (Map[ny][nx] && !Island[ny][nx])
			{
				Island[ny][nx] = num;
				InQ(ny, nx);
			}
		}
	}
}

void InQ(int yy, int xx)
{
	Q[Wp].y = yy;
	Q[Wp++].x = xx;
}

NODE * OutQ(void) { return &(Q[Rp++]); }

void Construct_Bridge(void)
{
	int i, r;

	min_Bridge = INF;
	for (i = 1; i < island_cnt; i++)
	{
		Init_Visit();
		r = FF_BFS_Bridge(i);
		//printf("r = %d,   ", r);
		if (min_Bridge > r) min_Bridge = r;
		//printf("min_Bridge = %d\n", min_Bridge);
		//Print_Visit();
	}
}

int FF_BFS_Bridge(int comp)
{
	NODE * out = (NODE *)0x0;
	int i, j;
	int sy, sx, ny, nx, check;

	Wp = Rp = 0;
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			if (Island[i][j] == comp)
			{
				InQ(i, j);
				Visit[i][j] = 0;
			}
		}
	}

	while (Wp > Rp)
	{
		//printf("Wp = %d, Rp = %d\n", Wp, Rp);
		out = OutQ();
		sy = out->y;    sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];        nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > N || Island[ny][nx] == comp) continue;
			if ( Island[ny][nx] ) return Visit[sy][sx];
			check = Visit[sy][sx] + 1;
			if ( !Island[ny][nx] && Visit[ny][nx] > check )
			{
				Visit[ny][nx] = check;
				InQ(ny, nx);
			}
		}
	}

	return INF;
}

void Print(void)
{
	printf("%d\n", min_Bridge );
}

void Print_Visit(void)
{
	printf("Print_Visit\n");
	for (int i = 1; i <= N; i++)
	{
		for (int j = 1; j <= N; j++)
		{
			printf("%4d", Visit[i][j]);
		}
		printf("\n");
	}
}
#endif




// 20191010
// [BOJ. 2580] 스도쿠
#if 0
#include <stdio.h>

void Input(void);
void Operation(void);
void DFS_Sudoku(int y, int x);
void Print_Sudoku(void);

int Sudoku[10][10];
int end_flag;

int main(void)
{
	Input();
	Operation();

	return 0;
}

void Input(void)
{
	int i, j;

	end_flag = 0;
	for (i = 1; i <= 9; i++)
	{
		for (j = 1; j <= 9; j++)
		{
			scanf("%d", &Sudoku[i][j]);
		}
	}
}

void Operation(void)
{
	int i, j, flag = 0;

	for (i = 1; i <= 9; i++)
	{
		for (j = 1; j <= 9; j++)
		{
			if (!Sudoku[i][j])
			{
				DFS_Sudoku(i, j);
				flag = 1;
				break;
			}
		}
		if (flag) break;
	}
}

void DFS_Sudoku(int y, int x)
{
	int cant_put[10] = { 0 };
	int i, j, nr, nc, ny = y, nx = x;

	if (end_flag) return;
	if (y == 10 && x == 10)
	{
		Print_Sudoku();
		end_flag = 1;
		return;
	}
	//printf("y = %d, x = %d\n", y, x);
	nr = ((y - 1) / 3) * 3;
	nc = ((x - 1) / 3) * 3;
	for (i = 1; i <= 9; i++) // 가로 세로 체크
	{
		if (Sudoku[y][i]) cant_put[Sudoku[y][i]] = 1;
		if (Sudoku[i][x]) cant_put[Sudoku[i][x]] = 1;
	}
	for (i = 1; i <= 3; i++)      // 3*3 구역 체크
	{
		for (j = 1; j <= 3; j++)
		{
			if (Sudoku[i + nr][j + nc]) cant_put[Sudoku[i + nr][j + nc]] = 1;
		}
	}
	//for(i = 1; i <= 9; i++) printf("%d ", cant_put[i]);
	//printf("\n");

	while (1)
	{
		if (++nx == 10)
		{
			ny++;
			nx = 1;
		}
		if (ny == 10)
		{
			nx = 10;
			break;
		}
		if (!Sudoku[ny][nx]) break;
	}


	for (i = 1; i <= 9; i++)
	{
		if (cant_put[i]) continue;      // 있다고 체크 되어있으면 써주면 안됨!
		cant_put[i] = 1;
		Sudoku[y][x] = i;
		//printf("Sudoku[%d][%d] = %d\n", y, x, Sudoku[y][x]);
		DFS_Sudoku(ny, nx);
		Sudoku[y][x] = 0;
		cant_put[i] = 0;
	}
}

void Print_Sudoku(void)
{
	int i, j;

	for (i = 1; i <= 9; i++)
	{
		for (j = 1; j <= 9; j++)
		{
			printf("%d ", Sudoku[i][j]);
		}
		printf("\n");
	}
}
#endif





// 20191011
// [SWEA. 5644] 무선 충전
/*
	★★ 교훈! ★★
	조건이 조금 많거나 복잡할 경우에는
	배열(전역변수 선언, 이후에 초기화 필요!!)을 이용하여 체크를 해준 다음에
	따로 함수를 만들어서 체크된 부분에 대해서만 조건을 하나씩 하나씩 적용하여 처리해주는 것이
	더욱 편하다!!
*/
#if 0
#include <stdio.h>
#define MAX	(110)
#define AAX	(10)
#define ABS(a)	( ( (a) < 0 ) ? -(a) : (a) )
#define DIST(a, b)	( ABS(a) + ABS(b) )

typedef struct
{
	int x, y;
	int dir[MAX];
	int Charge;
}PERSON;
PERSON A, B;

typedef struct
{
	int x, y;
	int Range;
	int Performance;
}BC;
BC bc[AAX];

void Input(void);
void Move_Get_Sum(void);
int Get_Chk_Sum(void);
void Init_chk(void);

int T;
int M, a;
int dy[5] = { 0, -1, 0, 1, 0 };
int dx[5] = { 0, 0, 1, 0, -1 };
int Max_Sum;
int chka[9], chkb[9];

int main(void)
{
	int t;

	freopen("in.txt", "r", stdin);
	scanf("%d", &T);
	for (t = 1; t <= T; t++)
	{
		Input();
		Move_Get_Sum();
		printf("#%d %d\n", t, Max_Sum);
	}
	
	return 0;
}

void Input(void)
{
	int i;

	A.y = 1;	A.x = 1;	A.dir[0] = 0;
	B.y = 10;	B.x = 10;	B.dir[0] = 0;
	scanf("%d %d", &M, &a);
	for (i = 1; i <= M; i++) { scanf("%d", &A.dir[i]); }
	for (i = 1; i <= M; i++) { scanf("%d", &B.dir[i]); }
	for (i = 1; i <= a; i++) { scanf("%d %d %d %d", &bc[i].x, &bc[i].y, &bc[i].Range, &bc[i].Performance); }
}

void Move_Get_Sum(void)
{
	int m, i;
	int nay, nax, nby, nbx;
	int adir, bdir;
	int flag;

	Max_Sum = 0;
	for (m = 0; m <= M; m++)
	{
		nax = A.x;	nay = A.y;	adir = A.dir[m];
		nbx = B.x;	nby = B.y;	bdir = B.dir[m];        // 매 초마다 A와 B의 좌표를 이동시킴(그 때의 주어진 방향들에 맞추어)
		//printf("[%d] A : x = %d, y = %d, adir = %d\n", m, nax, nay, adir);
		//printf("[%d] B : x = %d, y = %d, bdir = %d\n", m, nbx, nby, bdir);

		nax += dx[adir];	nay += dy[adir];
		nbx += dx[bdir];	nby += dy[bdir];

		flag = 0;
		for (i = 1; i <= a; i++)
		{       // A와 B 각각 어떤 배터리들의 범위에 걸리는지 확인한 후, chk 배열에 체크해줌
			if ( DIST( (bc[i].x - nax), (bc[i].y - nay) ) <= bc[i].Range )
			{
				//printf("[%d] DISTa = %d\n", i, DIST((bc[i].x - nax), (bc[i].y - nay)) <= bc[i].Range);
				chka[i] = 1;
				flag++;
			}
			if ( DIST( (bc[i].x - nbx), (bc[i].y - nby) ) <= bc[i].Range )
			{
				//printf("[%d] DISTb = %d\n", i, DIST((bc[i].x - nbx), (bc[i].y - nby)) <= bc[i].Range);
				chkb[i] = 1;
				flag++;
			}
		}
		// 혹시 한 명이라도 배터리의 범위에 걸리지 않으면 굳이 더해주지 않고, 걸린다면 더해준 후, chk배열 초기화
		if(flag) Max_Sum += Get_Chk_Sum();
		//printf("Max_Sum = %d\n", Max_Sum);
		Init_chk();
		
		A.x = nax;	A.y = nay;
		B.x = nbx;	B.y = nby;
	}
}
/*	변수 굳이 저렇게 많이 사용 안해줘도 됨!
	void Move_Get_Sum(void)
	{
		int m, i;
		int adir, bdir;
		int flag;

		Max_Sum = 0;
		for (m = 0; m <= M; m++)
		{
			adir = A.dir[m];    bdir = B.dir[m];
			A.x += dx[adir];    A.y += dy[adir];
			B.x += dx[bdir];    B.y += dy[bdir];

			flag = 0;
			for (i = 1; i <= a; i++)
			{
				if ( DIST( (bc[i].x - A.x), (bc[i].y - A.y) ) <= bc[i].Range )
				{
				chka[i] = 1;
				flag++;
				}
				if ( DIST( (bc[i].x - B.x), (bc[i].y - B.y) ) <= bc[i].Range )
				{
				chkb[i] = 1;
				flag++;
				}
			}
			if(flag) Max_Sum += Get_Chk_Sum();
			Init_chk();
		}
	}
*/

int Get_Chk_Sum(void)
{
	int max_sum = 0;
	int i, j;
	int sA, sB, check;

	for (i = 1; i <= a; i++)
	{
		for (j = 1; j <= a; j++)
		{
			sA = sB = 0;
			if ( chka[i] ) sA = bc[i].Performance;
			if ( chkb[j] ) sB = bc[j].Performance;
			if ( i == j && chka[i] == 1 && chkb[j] == 1 )
			{
				sA /= 2;		sB /= 2;
			}
			check = sA + sB;
			if ( max_sum < check ) max_sum = check;
		}
	}

	return max_sum;
}

void Init_chk(void)
{
	int i;

	for (i = 1; i <= a; i++)
	{
		chka[i] = chkb[i] = 0;
	}
}
#endif




// 20191011
// [BOJ. 14502] 연구소
// 처음 풀었던 버전
#if 0
#include <stdio.h>
#define MAX	(10)

typedef struct
{
	int y, x;
}NODE;
NODE Virus[11];
NODE Que[MAX * MAX * 2];

void Input(void);
void DFS_Choose_Wall(int L);
void InQ(int yy, int xx);
NODE * outQ(void);
int BFS_Get_Safety_Area(void);
void Print(void);

int N, M;
int Lab[MAX][MAX];
int Virus_cnt;
int chk_0;
int max_area;
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int Wp, Rp;
int lcnt;

int main(void)
{
	Input();
	DFS_Choose_Wall(1);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	max_area = 0;
	chk_0 = 0;		Virus_cnt = 1;
	scanf("%d %d", &N, &M);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			scanf("%d", &Lab[i][j]);
			if (Lab[i][j] == 2)			// 바이러스의 위치 저장
			{
				Virus[Virus_cnt].y = i;
				Virus[Virus_cnt++].x = j;
			}
			else if (!Lab[i][j]) chk_0++;	// 빈 칸의 개수 저장
		}
	}
}

void DFS_Choose_Wall(int L)
{
	int i, j, r = -1;

	if (r == chk_0) return;
	if (L > 3)
	{
		r = BFS_Get_Safety_Area();
		if (max_area < r) max_area = r;
		return;
	}

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			if (!Lab[i][j])	// 벽일 때 이것 선택해줌!
			{

				Lab[i][j] = 1;		chk_0--;
				DFS_Choose_Wall(L + 1);
				Lab[i][j] = 0;		chk_0++;
			}
		}
	}
}

void InQ(int yy, int xx)
{
	Que[Wp].y = yy;
	Que[Wp++].x = xx;
}

NODE * outQ(void)
{
	return &(Que[Rp++]);
}

int BFS_Get_Safety_Area(void)
{
	int Visit[MAX][MAX] = { 0 };
	NODE * out = (NODE *)0x0;
	int i, sy, sx, ny, nx;
	int chk = chk_0;

	lcnt++;
	Wp = Rp = 0;
	for (i = 1; i < Virus_cnt; i++)
	{
		InQ(Virus[i].y, Virus[i].x);
		Visit[Virus[i].y][Virus[i].x] = 1;
	}

	while (Wp > Rp)
	{
		out = outQ();
		sy = out->y;		sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];	nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > M) continue;
			if (!Lab[ny][nx] && !Visit[ny][nx])	// 연구실이 빈칸이고 아직 방문을 안했을 때
			{
				Visit[ny][nx] = 1;
				InQ(ny, nx);
				chk--;
			}
		}
	}
	return chk;
}

void Print(void)
{
	printf("%d\n", max_area);
}
#endif

// ★주영님 코드 참고 ver.	:	156 -> 24ms로 줄음...ㄷㄷ;;
/* ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
	걍 이중 for문으로 막 돌려서 조건 걸고 찾는 것보다, 
	차라리 구조체에 해당 데이터들만 저장해놓고 빼는 것이 더욱 효율적!!!!!
	=> for문을 최대 8*8번 돌 수 있다는 것은 동일
	   하지만 0의 개수가 적어지면 적어질 수록, 위의 방법으로는 계속 8*8번 + 매번 if문이지만,
										 아래의 방법으로는 0이 8개면 그냥 8번만 돌면 된다!!
*/
#if 0
#include <stdio.h>
#define MAX	(10)

typedef struct
{
	int y, x;
}NODE;
NODE Virus[11];
NODE Zero[MAX * MAX];
NODE Que[MAX * MAX * 2];

void Input(void);
void DFS_Choose_Wall(int L, int s_idx);
void InQ(int yy, int xx);
NODE * outQ(void);
int BFS_Get_Safety_Area(void);
void Print(void);

int N, M;
int Lab[MAX][MAX];
int Virus_cnt;
int Zero_cnt;
int chk_0;
int max_area;
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int Wp, Rp;

int main(void)
{
	freopen("in.txt", "r", stdin);

	Input();
	DFS_Choose_Wall(1, 1);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	max_area = 0;        chk_0 = 0;
	Zero_cnt = 1;        Virus_cnt = 1;
	scanf("%d %d", &N, &M);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			scanf("%d", &Lab[i][j]);
			if (Lab[i][j] == 2)			// 바이러스의 위치 저장
			{
				Virus[Virus_cnt].y = i;
				Virus[Virus_cnt++].x = j;
			}
			else if (!Lab[i][j])
			{
				Zero[Zero_cnt].y = i;
				Zero[Zero_cnt++].x = j;
			}
		}
	}
	chk_0 = Zero_cnt - 1;
}

void DFS_Choose_Wall(int L, int s_idx)
{
	int i, r;

	if (L > 3)
	{
		r = BFS_Get_Safety_Area();
		if (max_area < r) max_area = r;
		return;
	}

	for (i = s_idx; i < Zero_cnt; i++)
	{
		Lab[Zero[i].y][Zero[i].x] = 1;			chk_0--;
		DFS_Choose_Wall(L + 1, i + 1);
		Lab[Zero[i].y][Zero[i].x] = 0;			chk_0++;

	}
}

void InQ(int yy, int xx)
{
	Que[Wp].y = yy;
	Que[Wp++].x = xx;
}

NODE * outQ(void)
{
	return &(Que[Rp++]);
}

int BFS_Get_Safety_Area(void)
{
	int Visit[MAX][MAX] = { 0 };
	NODE * out = (NODE *)0x0;
	int i, sy, sx, ny, nx;
	int chk = chk_0;

	Wp = Rp = 0;
	for (i = 1; i < Virus_cnt; i++)
	{
		InQ(Virus[i].y, Virus[i].x);
		Visit[Virus[i].y][Virus[i].x] = 1;
	}

	while (Wp > Rp)
	{
		out = outQ();
		sy = out->y;		sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];	nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > M) continue;
			if (!Lab[ny][nx] && !Visit[ny][nx])	// 연구실이 빈칸이고 아직 방문을 안했을 때
			{
				Visit[ny][nx] = 1;
				InQ(ny, nx);
				chk--;
			}
		}
	}
	return chk;
}

void Print(void)
{
	printf("%d\n", max_area);
}
#endif




// 20191011
// DFS 연습! (조합, 순열, 부분집합, FF(?))
#if 0
#include <stdio.h>

void Input(void);
void DFS(int L, int s_dix);
void Print_Arr(int L);

int N;
int ARR[11];
int List[6];

int main(void)
{
	Input();
	DFS(1, 1);

	return 0;
}

void Input(void)
{
	int i;

	scanf("%d", &N);
	for (i = 1; i <= N; i++) scanf("%d", &ARR[i]);
}


/*
void DFS(int L, int s_idx)
{
	int i;

	if (L > 5)
	{
		Print_Arr(L);
		return;
	}

	for (i = s_idx; i < 10; i++)	// 조합용
	{
		List[L] = ARR[i];
		DFS(L + 1, i + 1);
		List[L] = 0;
	}
}
*/


void DFS(int L)
{

	if (L > 10)
	{
		Print_Arr(L);
		return;
	}
	
	List[L] = ARR[L];
	DFS(L + 1);

	List[L] = 0;
	DFS(L);
}


void Print_Arr(int L)
{
	int i;

	for (i = 1; i < L; i++) printf("%d ", List[i]);
	printf("\n");
}
#endif




// 20191011
// [BOJ. 16234] 인구 이동
#if 0
#include <stdio.h>
#define MAX	(55)
#define	ABS(a)	( ((a) < 0) ? -(a) : (a) )

typedef struct
{
	int y, x;
}NODE;
NODE Que[MAX * MAX * 2];

void Input(void);
void Operation(void);
void InQ(int yy, int xx);
NODE * OutQ(void);
int BFS(int sy, int sx, int comp);
void Init_Visit(void);
//void Print_Visit(void);

int N, L, R;
int A[MAX][MAX];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int Visit[MAX][MAX];
int Wp, Rp;
int result_cnt;

int main(void)
{
	freopen("in.txt", "r", stdin);

	Input();
	Operation();

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d %d %d", &N, &L, &R);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &A[i][j]);
		}
	}
}

void Operation(void)
{
	int flag, i, j, r, cnt;

	result_cnt = 0;
	while ( 1 )
	{
		cnt = 1;	flag = 0;
		Init_Visit();
		for (i = 1; i <= N; i++)
		{
			for (j = 1; j <= N; j++)
			{
				if ( !Visit[i][j] )
				{
					r = BFS(i, j, cnt);
					cnt++;
					if (r != 1) flag = 1;
				}
			}
		}
		//Print_Visit();
		//printf("flag = %d\n", flag);
		if ( !flag )
		{
			printf("%d\n", result_cnt);
			return;
		}
		result_cnt++;
	}
}

void InQ(int yy, int xx)
{
	Que[Wp].y = yy;
	Que[Wp++].x = xx;
}

NODE * OutQ(void)
{
	return &(Que[Rp++]);
}

int BFS(int sy, int sx, int comp)
{
	NODE * out = (NODE *)0x0;
	int i, j, check;
	int ny, nx, sum = 0, cnt = 0;

	Wp = Rp = 0;
	InQ(sy, sx);
	Visit[sy][sx] = comp;
	sum += A[sy][sx];	cnt++;
	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;	sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];	nx = sx + dx[i];
			if ( ny < 1 || ny > N || nx < 1 || nx > N ) continue;
			check = ABS(A[sy][sx] - A[ny][nx]);
			if ( check >= L && check <= R  && !Visit[ny][nx] )
			{
				InQ(ny, nx);
				Visit[ny][nx] = comp;
				sum += A[ny][nx];	cnt++;
			}
		}
	}
	
	if (Wp != 1)
	{
		for (i = 1; i <= N; i++)
		{
			for (j = 1; j <= N; j++)
			{
				if (Visit[i][j] == comp)
				{
					A[i][j] = sum / cnt;
				}
			}
		}
	}

	return Wp;
}

void Init_Visit(void)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			Visit[i][j] = 0;
		}
	}
}

void Print_Visit(void)
{
	int i, j;

	printf("Print_Visit\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			printf("%d ", Visit[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}
#endif




// 20191011
// [BOJ. 5373] 큐빙
#if 0
#include <stdio.h>
#define MAX	(1010)

enum dir{ U, D, F, B, L, R };

typedef struct { char com;	char dir; }COM;
COM C[MAX];

void Set_Data(void);
void Input(void);
void Operation(void);
void Clockwise(int dir);
void Counter_Clockwise(int dir);
void Print(void);


char cube[6][3][3];
/*
= { { { 'w', 'w', 'w' }, { 'w', 'w', 'w' }, { 'w', 'w', 'w' } },
					   { { 'y', 'y', 'y' }, { 'y', 'y', 'y' }, { 'y', 'y', 'y' } },
					   { { 'r', 'r', 'r' }, { 'r', 'r', 'r' }, { 'r', 'r', 'r' } },
					   { { 'o', 'o', 'o' }, { 'o', 'o', 'o' }, { 'o', 'o', 'o' } },
					   { { 'g', 'g', 'g' }, { 'g', 'g', 'g' }, { 'g', 'g', 'g' } },
					   { { 'b', 'b', 'b' }, { 'b', 'b', 'b' }, { 'b', 'b', 'b' } } };
					   */
int T;
int n;

int main(void)
{
	int i;

	freopen("in.txt", "r", stdin);
	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Set_Data();
		Input();
		Operation();
		Print();
	}

	return 0;
}

void Set_Data(void)
{
	int k, i, j;
	char color[6] = { 'w', 'y', 'r', 'o', 'g', 'b' };

	for (k = U; k <= R; k++)
	{
		for (i = 0; i < 3; i++)
		{
			for (j = 0; j < 3; j++)
			{
				cube[k][i][j] = color[k];
			}
		}
	}
}

void Input(void)
{
	int i;

	scanf("%d", &n);
	for (i = 0; i < n; i++)
	{
		scanf(" %c%c", &C[i].com, &C[i].dir);
	}
}

void Operation(void)
{
	int i;
	char com1, com2;
	char tmp = '\0';

	for (i = 0; i < n; i++)
	{
		com1 = C[i].com;	com2 = C[i].dir;
		switch ( com1 )
		{
			case 'U':
				if (com2 == '+')
				{
					Clockwise(U);
					tmp = cube[R][0][0];
					cube[R][0][0] = cube[D][2][2];
					cube[D][2][2] = cube[L][0][0];
					cube[L][0][0] = cube[F][0][0];
					cube[F][0][0] = tmp;

					tmp = cube[R][0][1];
					cube[R][0][1] = cube[D][2][1];
					cube[D][2][1] = cube[L][0][1];
					cube[L][0][1] = cube[F][0][1];
					cube[F][0][1] = tmp;

					tmp = cube[R][0][2];
					cube[R][0][2] = cube[D][2][0];
					cube[D][2][0] = cube[L][0][2];
					cube[L][0][2] = cube[F][0][2];
					cube[F][0][2] = tmp;
				}
				else
				{
					Counter_Clockwise(U);
					tmp = cube[D][2][2];
					cube[D][2][2] = cube[R][0][0];
					cube[R][0][0] = cube[F][0][0];
					cube[F][0][0] = cube[L][0][0];
					cube[L][0][0] = tmp;

					tmp = cube[D][2][1];
					cube[D][2][1] = cube[R][0][1];
					cube[R][0][1] = cube[F][0][1];
					cube[F][0][1] = cube[L][0][1];
					cube[L][0][1] = tmp;

					tmp = cube[D][2][0];
					cube[D][2][0] = cube[R][0][2];
					cube[R][0][2] = cube[F][0][2];
					cube[F][0][2] = cube[L][0][2];
					cube[L][0][2] = tmp;
				}
				break;
			case 'D':
				if (com2 == '+')
				{
					Clockwise(D);
					tmp = cube[F][2][2];
					cube[F][2][2] = cube[L][2][2];
					cube[L][2][2] = cube[U][0][0];
					cube[U][0][0] = cube[R][2][2];
					cube[R][2][2] = tmp;

					tmp = cube[F][2][1];
					cube[F][2][1] = cube[L][2][1];
					cube[L][2][1] = cube[U][0][1];
					cube[U][0][1] = cube[R][2][1];
					cube[R][2][1] = tmp;

					tmp = cube[F][2][0];
					cube[F][2][0] = cube[L][2][0];
					cube[L][2][0] = cube[U][0][2];
					cube[U][0][2] = cube[R][2][0];
					cube[R][2][0] = tmp;
			
				}
				else
				{
					Counter_Clockwise(D);
					tmp = cube[F][2][0];
					cube[F][2][0] = cube[R][2][0];
					cube[R][2][0] = cube[U][0][2];
					cube[U][0][2] = cube[L][2][0];
					cube[L][2][0] = tmp;

					tmp = cube[F][2][1];
					cube[F][2][1] = cube[R][2][1];
					cube[R][2][1] = cube[U][0][1];
					cube[U][0][1] = cube[L][2][1];
					cube[L][2][1] = tmp;

					tmp = cube[F][2][2];
					cube[F][2][2] = cube[R][2][2];
					cube[R][2][2] = cube[U][0][0];
					cube[U][0][0] = cube[L][2][2];
					cube[L][2][2] = tmp;
				}
				break;
			case 'F':
				if (com2 == '+')
				{
					Clockwise(F);
					tmp = cube[U][2][0];
					cube[U][2][0] = cube[L][2][2];
					cube[L][2][2] = cube[D][0][2];
					cube[D][0][2] = cube[R][0][0];
					cube[R][0][0] = tmp;

					tmp = cube[U][2][1];
					cube[U][2][1] = cube[L][1][2];
					cube[L][1][2] = cube[D][0][1];
					cube[D][0][1] = cube[R][1][0];
					cube[R][1][0] = tmp;

					tmp = cube[U][2][2];
					cube[U][2][2] = cube[L][0][2];
					cube[L][0][2] = cube[D][0][0];
					cube[D][0][0] = cube[R][2][0];
					cube[R][2][0] = tmp;
				}
				else
				{
					Counter_Clockwise(F);
					tmp = cube[U][2][0];
					cube[U][2][0] = cube[R][0][0];
					cube[R][0][0] = cube[D][0][2];
					cube[D][0][2] = cube[L][2][2];
					cube[L][2][2] = tmp;

					tmp = cube[U][2][1];
					cube[U][2][1] = cube[R][1][0];
					cube[R][1][0] = cube[D][0][1];
					cube[D][0][1] = cube[L][1][2];
					cube[L][1][2] = tmp;

					tmp = cube[U][2][2];
					cube[U][2][2] = cube[R][2][0];
					cube[R][2][0] = cube[D][0][0];
					cube[D][0][0] = cube[L][0][2];
					cube[L][0][2] = tmp;
				}
				break;
			case 'B':
				if (com2 == '+')
				{
					Clockwise(B);
					tmp = cube[U][0][2];
					cube[U][0][2] = cube[R][2][2];
					cube[R][2][2] = cube[D][2][0];
					cube[D][2][0] = cube[L][0][0];
					cube[L][0][0] = tmp;

					tmp = cube[U][0][1];
					cube[U][0][1] = cube[R][1][2];
					cube[R][1][2] = cube[D][2][1];
					cube[D][2][1] = cube[L][1][0];
					cube[L][1][0] = tmp;

					tmp = cube[U][0][0];
					cube[U][0][0] = cube[R][0][2];
					cube[R][0][2] = cube[D][2][2];
					cube[D][2][2] = cube[L][2][0];
					cube[L][2][0] = tmp;
				}
				else
				{
					Counter_Clockwise(B);
					tmp = cube[U][0][2];
					cube[U][0][2] = cube[L][0][0];
					cube[L][0][0] = cube[D][2][0];
					cube[D][2][0] = cube[R][2][2];
					cube[R][2][2] = tmp;

					tmp = cube[U][0][1];
					cube[U][0][1] = cube[L][1][0];
					cube[L][1][0] = cube[D][2][1];
					cube[D][2][1] = cube[R][1][2];
					cube[R][1][2] = tmp;

					tmp = cube[U][0][0];
					cube[U][0][0] = cube[L][2][0];
					cube[L][2][0] = cube[D][2][2];
					cube[D][2][2] = cube[R][0][2];
					cube[R][0][2] = tmp;
				}
				break;
			case 'L':
				if (com2 == '+')
				{
					Clockwise(L);
					tmp = cube[U][0][0];
					cube[U][0][0] = cube[B][2][2];
					cube[B][2][2] = cube[D][0][0];
					cube[D][0][0] = cube[F][0][0];
					cube[F][0][0] = tmp;

					tmp = cube[U][1][0];
					cube[U][1][0] = cube[B][1][2];
					cube[B][1][2] = cube[D][1][0];
					cube[D][1][0] = cube[F][1][0];
					cube[F][1][0] = tmp;

					tmp = cube[U][2][0];
					cube[U][2][0] = cube[B][0][2];
					cube[B][0][2] = cube[D][2][0];
					cube[D][2][0] = cube[F][2][0];
					cube[F][2][0] = tmp;
				}
				else
				{
					Counter_Clockwise(L);
					tmp = cube[U][0][0];
					cube[U][0][0] = cube[F][0][0];
					cube[F][0][0] = cube[D][0][0];
					cube[D][0][0] = cube[B][2][2];
					cube[B][2][2] = tmp;

					tmp = cube[U][1][0];
					cube[U][1][0] = cube[F][1][0];
					cube[F][1][0] = cube[D][1][0];
					cube[D][1][0] = cube[B][1][2];
					cube[B][1][2] = tmp;

					tmp = cube[U][2][0];
					cube[U][2][0] = cube[F][2][0];
					cube[F][2][0] = cube[D][2][0];
					cube[D][2][0] = cube[B][0][2];
					cube[B][0][2] = tmp;
				}
				break;
			default:
				if (com2 == '+')
				{
					Clockwise(R);
					tmp = cube[U][2][2];
					cube[U][2][2] = cube[F][2][2];
					cube[F][2][2] = cube[D][2][2];
					cube[D][2][2] = cube[B][0][0];
					cube[B][0][0] = tmp;

					tmp = cube[U][1][2];
					cube[U][1][2] = cube[F][1][2];
					cube[F][1][2] = cube[D][1][2];
					cube[D][1][2] = cube[B][1][0];
					cube[B][1][0] = tmp;

					tmp = cube[U][0][2];
					cube[U][0][2] = cube[F][0][2];
					cube[F][0][2] = cube[D][0][2];
					cube[D][0][2] = cube[B][2][0];
					cube[B][2][0] = tmp;
				}
				else
				{
					Counter_Clockwise(R);
					tmp = cube[U][2][2];
					cube[U][2][2] = cube[B][0][0];
					cube[B][0][0] = cube[D][2][2];
					cube[D][2][2] = cube[F][2][2];
					cube[F][2][2] = tmp;

					tmp = cube[U][1][2];
					cube[U][1][2] = cube[B][1][0];
					cube[B][1][0] = cube[D][1][2];
					cube[D][1][2] = cube[F][1][2];
					cube[F][1][2] = tmp;

					tmp = cube[U][0][2];
					cube[U][0][2] = cube[B][2][0];
					cube[B][2][0] = cube[D][0][2];
					cube[D][0][2] = cube[F][0][2];
					cube[F][0][2] = tmp;
				}
				break;
		}
	}
}

void Clockwise(int dir)
{
	int i, j;
	char tmp[4][4] = { 0 };

	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			tmp[j][2 - i] = cube[dir][i][j];
		}
	}

	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			cube[dir][i][j] = tmp[i][j];
		}
	}
}

void Counter_Clockwise(int dir)
{
	int i, j;
	char tmp[4][4] = {0};

	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			tmp[2 - j][i] = cube[dir][i][j];
		}
	}

	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			cube[dir][i][j] = tmp[i][j];
		}
	}
}

void Print(void)
{
	int i, j;

	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			printf("%c", cube[U][i][j]);
		}
		printf("\n");
	}

	/*
	for (i = 0; i < n; i++) printf("%c %c ", C[i].com, C[i].dir);
	printf("\n");
	*/
}
#endif




// 20191013
// [BOJ. 16235] 나무 재테크
// 다시 풀어본 ver. (다시 풀어봐야 함!)
#if 0
#include <stdio.h>
#define MAX     (12)

typedef struct
{
	int age[150];
	int min;
	int max;
}TREE;
TREE tree[MAX][MAX];

typedef struct
{
	int now, dead;
}NUTRITION;
NUTRITION A[MAX][MAX];

void Input(void);
void Print_Nutrition(void);
void Four_Season(void);
void Print(void);
void Print_Age(void);

int N, M, K;
int Y[MAX][MAX];
int dy[8] = { -1, -1, -1, 0, 1, 1, 1, 0 };
int dx[8] = { -1, 0, 1, 1, 1, 0, -1, -1 };

int main(void)
{
	freopen("in.txt", "r", stdin);
	Input();
	while (K--)
	{
		Print_Nutrition();
		Four_Season();
		Print_Nutrition();
		printf("===========\n");
	}
	Print();

	return 0;
}

void Input(void)
{
	int i, j, x, y, a;

	scanf("%d %d %d", &N, &M, &K);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &(A[i][j].now));      // 매해 겨울에 더해줄 양분 값
			Y[i][j] = 5;    // 초기 양분의
		}
	}
	for (i = 0; i < M; i++)
	{
		scanf("%d %d %d", &x, &y, &a);
		tree[y][x].age[a]++;  // 초기 각 나무의 위치와 그 나무의 나이
		tree[y][x].max = tree[y][x].min = a;
	}
}

void Print_Nutrition(void)
{
	int i, j;

	printf("Print_Nutrition\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			printf("%2d ", Y[i][j]);
		}
		printf("\n");
	}
}

void Four_Season(void)
{
	int i, j, c, d;
	int ny, nx, cnt, t;

	// 디버깅
	//printf("[before] how many trees? : %d\n", M);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++) // 땅의 좌표 값
		{
			// 각 땅에 있는 나무들 순서대로!(나이 내림차순으로 정렬되어 있을 것인데, 거꾸로 빼면 오름차순으로 넣어주는 것!)
			for (c = tree[i][j].min; c <= tree[i][j].max; c++)
			{
				if ( !tree[i][j].age[c] ) continue;
				// [Spring] : Y[i][j]에 있는 양분 빨아들이기 (양분 부족하면 그 나무 즉사)
				cnt = tree[i][j].age[c];
				t = Y[i][j] / cnt;
				if (t == 0) break;


				if (Y[i][j] >= tree[i][j].age[c])
				{
					Y[i][j] -= tree[i][j].age[c];
					// [Autumn] : 봄을 지나면서 죽지 않고 살아 있는 나무에 대해서만! 나이가 5의 배수일 때, 8방 아기 나무 생성
					if ( !(++tree[i][j].age[c] % 5) )  // 봄에 양분을 먹고 바로 한 살 증가!
					{
						for (d = 0; d < 8; d++)
						{
							ny = i + dy[d];         nx = j + dx[d];
							if (ny < 1 || ny > N || nx < 1 || nx > N) continue;
							tree[ny][nx].age[tree[ny][nx].sub_Wp++] = 1;
							//printf("[birth] y = %d, x = %d, age[%d] = %d <sub_Wp = %d>\n", ny, nx, tree[ny][nx].sub_Wp-1, tree[ny][nx].age[ tree[ny][nx].sub_Wp-1 ], tree[ny][nx].sub_Wp);
							M++;
						}
					}
				}
				else    // [Summer]
				{
					A[i][j].dead += (tree[i][j].age[c] / 2);
					end++;                  M--;
					//printf("[death] y = %d, x = %d, age[%d] = %d <Rp = %d>\n", i, j, c, tree[i][j].age[c], end);
				}
			}
			tree[i][j].Rp = end;
		}
	}
	// [Winter]
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			// 현재 살아 있는 나무 갱신
			tree[i][j].Wp = tree[i][j].sub_Wp;
			// 여긴 겨울
			Y[i][j] += (A[i][j].now + A[i][j].dead);
			A[i][j].dead = 0;
		}
	}
	// 디버깅
	//printf("[after] how many trees? : %d\n", M);
	//Print_Age();
}

void Print(void)
{
	printf("%d\n", M);
}

void Print_Age(void)
{
	int i, j, w;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			printf("Wp = tree[%d][%d].Wp = %d ,  Rp = tree[%d][%d].Rp = %d\n", i, j, tree[i][j].Wp, i, j, tree[i][j].Rp);
			for (w = 0; w < tree[i][j].Wp; w++)
			{
				printf("[ y = %d, x = %d ] age[%d] = %d\n", i, j, w, tree[i][j].age[w]);
			}
		}
		printf("------------\n");
	}
	printf("1 time end\n\n");
}
#endif






// 20191014
// [ 문제 A0: [TST]버스 갈아타기 ]
/*
		인접 배열을 활용하는 방법을 잘 모르는 것 같음!
*/
/*
	// ★인접 만들기★
	for (b = 1; b < i; b++)
	{
		if (Bus[b].y2 < Bus[i].y1) continue;
		if (Bus[b].x2 < Bus[i].x1) continue;
		if (Bus[b].y1 > Bus[i].y2) continue;
		if (Bus[b].x1 > Bus[i].x2) continue;
		A[Bus[b].id][Bus[i].id] = A[Bus[i].id][Bus[b].id] = 1;
	}
*/
#if 0
#include <stdio.h>
#define KMAX		(5010)
#define INF			(987654321)

typedef struct { int sy, sx, ey, ex, id; }NODE;
NODE BUS[KMAX];
NODE ME;

void Input(void);
void Find_First_Last_Bus(void);
void BFS(void);
void Print(void);
void Print_Injub(void);
void Print_Chk(void);

int N, M;
int K;
int min_bus;
int chk_s[KMAX];
int chk_e[KMAX];
int s_cnt, e_cnt;
int Injub[KMAX][KMAX];
int Q[KMAX];
int Wp, Rp;
int chk[KMAX];

int main(void)
{
	freopen("in.txt", "r", stdin);

	Input();
	Find_First_Last_Bus();
	BFS();

	Print_Injub();
	Print_Chk();	

	Print();

	return 0;
}

void Input(void)
{
	int i, j;
	int sy, sx, dy, dx;
	int min_ix, max_ix, min_iy, max_iy, iid;
	int min_jx, max_jx, min_jy, max_jy, jid;

	scanf("%d %d", &M, &N);
	scanf("%d", &K);
	for (i = 1; i <= K; i++)
	{
		scanf("%d %d %d %d %d", &iid, &sx, &sy, &dx, &dy);
		BUS[i].id = iid;
		if (sy <= dy)
		{
			BUS[i].sy = min_iy = sy;
			BUS[i].ey = max_iy = dy;
		}
		else
		{
			BUS[i].sy = min_iy = dy;
			BUS[i].ey = max_iy = sy;
		}
		if (sx <= dx)
		{
			BUS[i].sx = min_ix = sx;
			BUS[i].ex = max_ix = dx;
		}
		else
		{
			BUS[i].sx = min_ix = dx;
			BUS[i].ex = max_ix = sx;
		}

		for (j = 1; j < i; j++)
		{
			jid = BUS[j].id;
			min_jy = BUS[j].sy;		max_jy = BUS[j].ey;
			min_jx = BUS[j].sx;		max_jx = BUS[j].ex;

			// 선분이지만, 그냥 네모난 도형이라고 생각하고 푸는 것이 좋다!
			if (max_jy < min_iy) continue;
			if (max_jx < min_ix) continue;
			if (min_jy > max_iy) continue;
			if (min_jx > max_ix) continue;
			Injub[iid][jid] = Injub[jid][iid] = 1;
		}
			/*
			if ( min_ix == max_ix )	// i는 수직선
			{
				if ( min_jx == max_jx )	// j는 수직선
				{
					if ( min_jx != min_ix ) continue;
					if ( min_iy <= min_jy && min_jy <= max_iy || min_iy <= max_jy && max_jy <= max_iy )
					{
						Injub[iid][jid] = Injub[jid][iid] = 1;
					}
				}
				else if ( min_jy == max_jy )	// j는 수평선
				{
					if ( min_jx <= min_ix && min_ix <= max_jx && min_iy <= min_jy && min_jy <= max_iy )
					{
						Injub[iid][jid] = Injub[jid][iid] = 1;
					}
				}				
			}
			else if ( min_iy == max_iy )	// i는 수평선
			{
				if (min_jx == max_jx)	// j는 수직선
				{
					if (min_jy <= min_iy && min_iy <= max_jy && min_ix <= min_jx && min_jx <= max_ix)
					{
						Injub[iid][jid] = Injub[jid][iid] = 1;
					}
				}
				else if (min_jy == max_jy)	// j는 수평선
				{
					if (min_jy != min_iy) continue;
					if (min_ix <= min_jx && min_jx <= max_ix || min_iy <= max_jy && max_jy <= max_iy)
					{
						Injub[iid][jid] = Injub[jid][iid] = 1;
					}
				}
			}
			*/
	}
	scanf("%d %d %d %d ", &ME.sx, &ME.sy, &ME.ex, &ME.ey);
}

void Find_First_Last_Bus(void)
{
	int i;
	int sy, sx, ey, ex, id;
	int msy = ME.sy, msx = ME.sx, mey = ME.ey, mex = ME.ex;

	s_cnt = e_cnt = 0;
	min_bus = INF;
	for (i = 1; i <= K; i++)	// 각 노선에 대하여
	{
		id = BUS[i].id;
		sx = BUS[i].sx;		ex = BUS[i].ex;
		sy = BUS[i].sy;		ey = BUS[i].ey;		
		// 시작점이 어떤 버스 노선에 걸리는지
		if ( sx == ex && sx == msx )	// 수직선일 때 && 시작위치의 x좌표와 같을 때
		{
			if ( sy <= msy && msy <= ey ) chk_s[s_cnt++] = id;
		}
		else if ( sy == ey && sy == msy )	// 수평선일 때 && 시작위치의 y좌표와 같을 때
		{
			if ( sx <= msx && msx <= ex ) chk_s[s_cnt++] = id;
		}
		// 도착점이 어떤 버스 노선에 걸리는지
		if ( sx == ex && sx == mex )			// 수직선일 때 && 도착위치의 x좌표와 같을 때
		{
			if ( sy <= mey && mey <= ey ) chk_e[e_cnt++] = id;
		}
		else if ( sy == ey && sy == mey )	// 수평선일 때 && 도착위치의 y좌표와 같을 때
		{
			if ( sx <= mex && mex <= ex ) chk_e[e_cnt++] = id;
		}
	}
}

void BFS(void)
{
	int out, i, e, id, check;

	Wp = Rp = 0;
	for (i = 0; i < s_cnt; i++)
	{
		Q[Wp++] = chk_s[i];
		chk[ chk_s[i] ] = 1;
	}

	while (Wp > Rp)
	{
		out = Q[Rp++];
		//printf("Wp = %d, Rp = %d, out = %d\n", Wp, Rp, out);
		for (i = 1; i <= K; i++)
		{
			id = BUS[i].id;			check = chk[out] + 1;
			if ( Injub[out][id] && !chk[id] )
			{
				chk[id] = check;
				Q[Wp++] = id;
			}
		}
		//for (int q = 1; q <= K; q++) printf("%d ", chk[q]);
		//printf("\n");
	}
	for (e = 0; e < e_cnt; e++)
	{
		if (min_bus > chk[ chk_e[e] ]) min_bus = chk[ chk_e[e] ];
	}
}

void Print(void)
{
	printf("%d\n", min_bus);
}

void Print_Injub(void)
{
	int i, j;

	printf("Print_Injub\n");
	for (i = 1; i <= K; i++)
	{
		for (j = 1; j <= K; j++)
		{
			printf("%d ", Injub[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}

void Print_Chk(void)
{
	int i;

	for (i = 0; i < s_cnt; i++) printf("%d ", chk_s[i]);
	printf("\n");
	for (i = 0; i < e_cnt; i++) printf("%d ", chk_e[i]);
	printf("\n");
}
#endif

// 광은님 ver.
#if 0
#include <stdio.h>

#define MAX (5010)

typedef struct st {
	int id;
	int x1;
	int y1;
	int x2;
	int y2;
	char d;
} BUS;

int X, Y, K;
int SX, SY, DX, DY;
int wp, rp;
int A[MAX][MAX];
int Visit[MAX];
BUS Bus[MAX];
BUS Queue[MAX];

void InQueue(BUS bus) { Queue[wp++] = bus; }
BUS OutQueue(void) { return Queue[rp++]; }

void Input(void);
int BFS(void);

int main(void)
{
	Input();
	printf("%d\n", BFS());

	for (int i = 1; i <= K; i++)
	{
		for (int j = 1; j <= K; j++)
		{
			printf("%d ", A[i][j]);
		}
		printf("\n");
	}

	return 0;
}

void Input(void)
{
	int i;
	int b;
	int id, x1, x2, y1, y2;

	scanf("%d %d %d", &X, &Y, &K);

	for (i = 1; i <= K; i++)
	{
		// 입력
		scanf("%d %d %d %d %d", &id, &x1, &y1, &x2, &y2);
		Bus[i].id = id;
		if (x1 < x2)
		{
			Bus[i].x1 = x1;
			Bus[i].x2 = x2;
		}
		else
		{
			Bus[i].x1 = x2;
			Bus[i].x2 = x1;
		}
		if (y1 < y2)
		{
			Bus[i].y1 = y1;
			Bus[i].y2 = y2;
		}
		else
		{
			Bus[i].y1 = y2;
			Bus[i].y2 = y1;
		}
		// 인접 만들기
		for (b = 1; b < i; b++)
		{
			if (Bus[b].y2 < Bus[i].y1) continue;
			if (Bus[b].x2 < Bus[i].x1) continue;
			if (Bus[b].y1 > Bus[i].y2) continue;
			if (Bus[b].x1 > Bus[i].x2) continue;
			A[Bus[b].id][Bus[i].id] = A[Bus[i].id][Bus[b].id] = 1;
		}
	}

	scanf("%d %d %d %d", &SX, &SY, &DX, &DY);
}

int BFS(void)
{
	BUS out;
	int i;

	// 시작점 넣기
	wp = rp = 0;
	for (i = 1; i <= K; i++)
	{
		if (((Bus[i].x1 <= DX) && (DX <= Bus[i].x2)) && ((Bus[i].y1 <= DY) && (DY <= Bus[i].y2)))
		{
			Bus[i].d = 1;
		}
		if (((Bus[i].x1 <= SX) && (SX <= Bus[i].x2)) && ((Bus[i].y1 <= SY) && (SY <= Bus[i].y2)))
		{
			InQueue(Bus[i]);
			Visit[Bus[i].id] = 1;
		}
	}

	// go
	while (rp < wp)
	{
		out = OutQueue();
		if (out.d == 1) return Visit[out.id];
		for (i = 1; i <= K; i++)
		{
			if (Visit[Bus[i].id] != 0) continue;
			if (A[out.id][Bus[i].id] == 1)
			{
				Visit[Bus[i].id] = Visit[out.id] + 1;
				InQueue(Bus[i]);
			}
		}
	}

	return -1;
}
#endif



// 20191014
// [ 문제 A1: [TEST] 페인트2 ]
/*
	* 문제 제대로 안 읽어보고, 많이 풀어봤던 BFS라고 생각하고 바로 들어감
		- 잘못됨을 인지하고 다시 읽어봤지만, 당황해서 두 번이나 잘못 풀어서 다시 지웠음...
	* 문제 푸는데 가장 중요했던 아이디어는? : 오염된 지역에서 더 이상 퍼지지 않고 막히는 것이 아니라,
										거기에서도 더 퍼질 수 있다는 것! (마치 연구소3처럼!)
	[ Review ]
	* 2번인지 3번인지 몇 번 떨어뜨리는지 고정되어 있잖아? 그러면 4중 루프면은 바로 해결될 것 => 아이디어!!
	* 그런데 Map이 워낙 작기 때문에 어떻게 풀든 풀리긴 함
	* 추가적으로 돌아가는 경로나 비효율적인 경우를 없애려고 조건을 넣어줄 때,
	  실제로 그렇게 작동을 할지 설계 단에서부터 생각을 잘 해야 하고 + 스스로 TC를 만들어서 넣어봐라! (매우 작게 or 매우 크게)
*/
#if 0
#include <stdio.h>
#define MAX	(30)

typedef struct { int y, x; }NODE;
NODE dot[MAX * MAX * 2];
NODE Que[MAX * MAX * 2];

void Input(void);
void DFS(int L, int s_idx);
int BFS(void);
void InQ(int yy, int xx);
NODE * OutQ(void);
void Init_Visit(void);
void Print(void);
void Print_List(int L);

int dot_cnt;
int N;
int Map[MAX][MAX];
int Range;
int max_cnt;
int Visit[MAX][MAX];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int Wp, Rp;
int List[3];

int main(void)
{
	freopen("in.txt", "r", stdin);

	Input();
	DFS(1, 1);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	dot_cnt = 1;		max_cnt = 0;
	scanf("%d", &N);
	scanf("%d", &Range);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &Map[i][j]);
			dot[dot_cnt].y = i;
			dot[dot_cnt++].x = j;
		}
	}
}

void DFS(int L, int s_idx)
{
	int i, j, r;

	if (L > 2)
	{
		//Print_List(L);
		Init_Visit();
		r = BFS();
		//printf("r = %d\n", r);
		if (max_cnt < r) max_cnt = r;
		return;

	}

	for (i = s_idx; i < dot_cnt; i++)
	{
		List[L] = i;
		DFS(L + 1, i + 1);
		List[L] = 0;
	}
}


int BFS(void)
{
	NODE * out = (NODE *)0x0;
	int i, cnt = 0;
	int sy, sx, ny, nx;

	Wp = Rp = 0;
	for (i = 1; i <= 2; i++)
	{
		sy = dot[ List[i] ].y;	sx = dot[ List[i] ].x;
		InQ( sy, sx );
		Visit[sy][sx] = 0;
		if ( !Map[sy][sx] ) cnt++;
	}

	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;		sx = out->x;
		if (Visit[sy][sx] == Range) continue;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];	nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > N ) continue;
			if ( Visit[ny][nx] == -1 )
			{
				InQ(ny, nx);
				Visit[ny][nx] = Visit[sy][sx] + 1;
				if ( !Map[ny][nx] )	cnt++;
			}
		}
	}
	return cnt;
}

void InQ(int yy, int xx)
{
	Que[Wp].y = yy;
	Que[Wp++].x = xx;
}

NODE * OutQ(void) { return &(Que[Rp++]); }

void Init_Visit(void)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			Visit[i][j] = -1;
		}
	}
}

void Print_List(int L)
{
	int i;

	printf("Print_List\n");
	for (i = 1; i < L; i++) printf("%d ", List[i]);
	printf("\n");
}

void Print(void)
{
	printf("%d\n", max_cnt);
}
#endif

// 다른 ver. - 그래도 시간 오래 걸림
#if 0
#include <stdio.h>
#define MAX	(30)

typedef struct { int y, x; }NODE;
NODE Que[MAX * MAX * 2];
NODE List[3];

void Input(void);
void DFS(int L, int s_idx);
int BFS(void);
void InQ(int yy, int xx);
NODE * OutQ(void);
void Print(void);

int N;
int Map[MAX][MAX];
int Range;
int max_cnt;
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int Wp, Rp;

int main(void)
{
	Input();
	DFS(1, 1);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	max_cnt = 0;
	scanf("%d", &N);
	scanf("%d", &Range);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &Map[i][j]);
		}
	}
}

void DFS(int L, int s_idx)
{
	int i, j, r;

	if (L > 2)
	{
		r = BFS();
		if (max_cnt < r) max_cnt = r;
		return;

	}

	for (i = s_idx; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			List[L].y = i;		List[L].x = j;
			DFS(L + 1, i);
			List[L].y = 0;		List[L].x = 0;
		}
	}
}


int BFS(void)
{
	NODE * out = (NODE *)0x0;
	int i, cnt = 0;
	int sy, sx, ny, nx;
	int Visit[MAX][MAX] = { 0 };

	Wp = Rp = 0;
	for (i = 1; i <= 2; i++)
	{
		sy = List[i].y;		sx = List[i].x;
		InQ(sy, sx);
		Visit[sy][sx] = 1;
		if (!Map[sy][sx]) cnt++;
	}

	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;		sx = out->x;
		if (Visit[sy][sx] == Range + 1) continue;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];	nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > N) continue;
			if (Visit[ny][nx] == 0)
			{
				InQ(ny, nx);
				Visit[ny][nx] = Visit[sy][sx] + 1;
				if (!Map[ny][nx])	cnt++;
			}
		}
	}
	return cnt;
}

void InQ(int yy, int xx)
{
	Que[Wp].y = yy;
	Que[Wp++].x = xx;
}

NODE * OutQ(void) { return &(Que[Rp++]); }

void Print(void)
{
	printf("%d\n", max_cnt);
}
#endif




// 20191014
// 문제 A2: [TEST] 미로탈출
#if 0
#include <stdio.h>
#define MAX	(35)
#define INF	(987654321)

typedef struct { int y, x; int b; }NODE;
NODE Que[MAX * MAX * 4];
NODE start, end;

void Input(void);
int BFS(void);
void Init_Visit(void);
void InQ(int yy, int xx, int bb);
NODE * OutQ(void);
void Print(void);
void Print_Visit(void);

int R, C;
int Map[MAX][MAX];
int Visit[MAX][MAX][4];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int min_dist;
int Wp, Rp;

int main(void)
{
	//freopen("in.txt", "r", stdin);

	Input();
	Init_Visit();
	min_dist = BFS();
	//Print_Visit();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	min_dist = INF;
	scanf("%d %d", &R, &C);
	for (i = 1; i <= R; i++)
	{
		for (j = 1; j <= C; j++)
		{
			scanf("%d", &Map[i][j]);
			if (Map[i][j] == 3)
			{
				start.y = i;	start.x = j;
			}
			else if (Map[i][j] == 4)
			{
				end.y = i;		end.x = j;
			}
		}
	}
}

int BFS(void)
{
	NODE * out = (NODE *)0x0;
	int i, check;
	int sy, sx, ny, nx, bb;

	Wp = Rp = 0;
	for (i = 0; i <= 3; i++)
	{
		InQ(start.y, start.x, i);
		Visit[start.y][start.x][i] = 1;
	}
	
	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;	sx = out->x;	bb = out->b;
		if ( bb > 3 ) continue;
		if ( sy == end.y && sx == end.x ) return Visit[sy][sx][bb] - 1;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];		nx = sx + dx[i];
			if ( Map[ny][nx] == 1 ) continue;
			check = Visit[sy][sx][bb] + 1;
			if ( Map[ny][nx] == 2 && bb < 3 )
			{
				if ( Visit[ny][nx][bb + 1] <= check ) continue;
				Visit[ny][nx][bb + 1] = check;
				InQ(ny, nx, bb + 1);
			}
			else if ( Map[ny][nx] == 0 || Map[ny][nx] == 4 ) 	// 그냥 갈 수 있는 공간이라면 그냥 갈 수 있어!
			{
				if ( Visit[ny][nx][bb] <= check ) continue;
				Visit[ny][nx][bb] = check;
				InQ(ny, nx, bb);
			}
		}
	}

	return INF;
}

void Init_Visit(void)
{
	int k, i, j;

	for (k = 0; k <= 3; k++)
	{
		for (i = 1; i <= R; i++)
		{
			for (j = 1; j <= C; j++)
			{
				Visit[i][j][k] = INF;
			}
		}
	}
}

void InQ(int yy, int xx, int bb)
{
	Que[Wp].y = yy;
	Que[Wp].x = xx;
	Que[Wp++].b = bb;
}

NODE * OutQ(void) { return &(Que[Rp++]); }

void Print_Visit(void)
{
	int i, j, b;

	printf("Print_Visit\n");
	for (b = 0; b <= 3; b++)
	{
		printf("[b = %d]\n", b);
		for (i = 1; i <= R; i++)
		{
			for (j = 1; j <= C; j++)
			{
				printf("%3d ", Visit[i][j][b]);
			}
			printf("\n");
		}
	}
	
}

void Print(void)
{
	if (min_dist == INF) min_dist = -1;
	printf("%d\n", min_dist);
}
#endif




// 20191014
// 문제 A3: [TEST] 갤럭시
#if 0
#include <stdio.h>
#define MAX	(11)
#define ABS(a)	( ( (a) < 0 ) ? -(a) : (a) )

void Input(void);
void DFS(int L, int idx, int sum);
void Print(void);
void Print_List(int L);

int N;
int ARR[MAX];
int List[MAX];
int chk[MAX];
int chk_sum[1001];
int cnt;

int main(void)
{
	//freopen("in.txt", "r", stdin);

	Input();
	chk[1] = 1;
	DFS(1, 1, 0);
	chk[1] = 0;
	Print();

	return 0;
}

void Input(void)
{
	int i;

	cnt = 0;
	scanf("%d", &N);
	for (i = 1; i <= N; i++) scanf("%d", &ARR[i]);
}

void DFS(int L, int idx, int sum)
{
	int i;

	if (idx == N)
	{
		//Print_List(L);
		//printf("sum = %d\n", sum);
		if (++chk_sum[sum] == 1) cnt++;
		return;
	}

	if (L & 1)
	{
		for (i = idx + 1; i <= N; i++)
		{
			if (chk[i]) continue;
			chk[i] = 1;
			List[L] = ABS(ARR[i] - ARR[idx]);
			DFS(L + 1, i, sum + List[L]);
			List[L] = 0;
			chk[i] = 0;
		}
	}
	else
	{
		for (i = idx - 1; i >= 1; i--)
		{
			if (chk[i]) continue;
			chk[i] = 1;
			List[L] = ABS(ARR[idx] - ARR[i]);
			DFS(L + 1, i, sum + List[L]);
			List[L] = 0;
			chk[i] = 0;
		}
	}
}

void Print_List(int L)
{
	int i;

	printf("Print_List\n");
	for (i = 1; i < L; i++) printf("%4d ", List[i]);
	printf("\n");
}

void Print(void)
{
	printf("%d\n", cnt);
}
#endif




// 20191014
// [BOJ. 17140] 이차원 배열과 연산
#if 0
#include <stdio.h>
#define MAX	(101)

typedef struct { int num, cnt; }OPERATION;
OPERATION chk[MAX];

void Input(void);
void Set_Struct(int num);
void Operation(void);
void Operation_R(void);
void Operation_C(void);
void Sort(int max);
void Print(void);
void Print_ARR(int max_row, int max_col);

int r, c, k;
int ARR[MAX][MAX];
int max_row, max_col;
int sec;
int chk_R[MAX];	// 구조체로 하는 것이 옳을까?
int chk_C[MAX];

int main(void)
{
	freopen("in.txt", "r", stdin);

	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d %d %d", &r, &c, &k);
	for (i = 1; i <= 3; i++) for (j = 1; j <= 3; j++) scanf("%d", &ARR[i][j]);
}

void Set_Struct(int num)
{
	int i;

	for (i = 0; i <= num; i++)
	{
		chk[i].num = i;
		chk[i].cnt = 0;
	}
}

void Operation(void)
{
	Set_Struct(100);
	max_row = max_col = 3;
	while ( ARR[r][c] != k )
	{
		// R연산 조건
		if (max_row >= max_col) Operation_R();
		// C연산 조건
		else Operation_C();

		if (++sec > 100)
		{
			sec = -1;
			return;
		}
		printf("[ %d ]\n", sec);
		//Print_ARR(max_row, max_col);
	}
}

void Operation_R(void)
{
	int i, j, col, max;

	for (i = 1; i <= max_row; i++)
	{
		col = 0;		max = 0;
		// 각 행을 기준으로 모든 열(max_row까지)에 있는 수들을 카운트 해줌 
		for (j = 1; j <= max_col; j++)
		{
			chk[ARR[i][j]].cnt++;
			if (max < ARR[i][j]) max = ARR[i][j];
		}
		// 그 후 일단 그 곳까지는 0으로 깔아줌
		// (만약 R연산 후의 열 개수가 증가한다면, 덮히게 되므로 필요 없을 수도 있지만, 반대의 경우에는 따로 처리해주기 귀찮기 때문!)
		for (j = 1; j <= max_col; j++) ARR[i][j] = 0;
		// 선> 갯수 오름차순, 후> 수의 크기 오름차순
		Sort(max);
		// 정렬된 후 깔아줌
		for (j = 1; j <= max; j++)
		{
			if (chk[j].cnt == 0) continue;
			ARR[i][++col] = chk[j].num;
			ARR[i][++col] = chk[j].cnt;
		}
		if (max_col < col) max_col = col;
		Set_Struct(max);
	}
}

void Operation_C(void)
{
	int i, j, row, max;

	for (j = 1; j <= max_col; j++)
	{
		row = 0;		max = 0;
		// 각 열을 기준으로 모든 행(max_col까지)에 있는 수들을 카운트 해줌 
		for (i = 1; i <= max_row; i++)
		{
			chk[ARR[i][j]].cnt++;
			if (max < ARR[i][j]) max = ARR[i][j];
		}
		// 그 후 일단 그 곳까지는 0으로 깔아줌
		// (만약 C연산 후의 열 개수가 증가한다면, 덮히게 되므로 필요 없을 수도 있지만, 반대의 경우에는 따로 처리해주기 귀찮기 때문!)
		for (i = 1; i <= max_row; i++) ARR[i][j] = 0;
		// 선> 갯수 오름차순, 후> 수의 크기 오름차순
		Sort(max);
		// 정렬된 후 깔아줌
		for (i = 1; i <= max; i++)
		{
			if (chk[i].cnt == 0) continue;
			ARR[++row][j] = chk[i].num;
			ARR[++row][j] = chk[i].cnt;
		}
		if (max_row < row) max_row = row;
		Set_Struct(max);
	}
}

void Sort(int max)
{
	int i, j;
	OPERATION tmp = {0, 0};

	for (i = 1; i < max; i++)
	{
		for (j = i + 1; j <= max; j++)
		{
			if ( (chk[i].cnt > chk[j].cnt) 
				|| (chk[i].cnt == chk[j].cnt && chk[i].num > chk[j].num) )
			{
				tmp = chk[i];
				chk[i] = chk[j];
				chk[j] = tmp;
			}
		}
	}
}

void Print_ARR(int max_row, int max_col)
{
	int i, j;

	printf("Print_ARR\n");
	for (i = 1; i <= max_row; i++)
	{
		for (j = 1; j <= max_col; j++)
		{
			printf("%2d ", ARR[i][j]);
		}
		printf("\n");
	}
	printf("\n\n");
}

void Print(void)
{
	printf("%d\n", sec);
}
#endif




// 20191015
// 문제 A4: [TEST] 불켜기 - Linked List
/*
		FF_DFS, FF_BFS 둘 다 풀 수 있음!!
*/
#if 0
#include <stdio.h>
#define MAX	(110)
#define MAXQ	(MAX * MAX)

typedef struct _st
{ 
	int x, y; 
	struct _st * next;
}NODE;
NODE Que[MAXQ];
NODE sw[20001];

typedef struct
{
	int flag;
	struct _st * next;
}ROOM;
ROOM Room[MAX][MAX];

void Input(void);
void Print_Link(void);
void BFS_Switch_On(int sy, int sx);
void InQ(int yy, int xx, NODE * nn);
NODE * OutQ(void);
void Print_Flag(void);
void Init_Struct_Visit(void);

int T, N, M;	// TC, 방의 크기, 스위치 개수
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int Visit[MAX][MAX];
int room_cnt;
int Wp, Rp;

int main(void)
{
	int t;

	freopen("in.txt", "r", stdin);
	scanf("%d", &T);
	for (t = 1; t <= T; t++)
	{
		Input();
		//Print_Link();
		BFS_Switch_On(1, 1);
		//Print_Flag();
		printf("%d\n", room_cnt);
		Init_Struct_Visit();
	}

	return 0;
}

void Input(void)
{
	int i, x, y, a, b;
	NODE * head = (NODE *)0x0;

	room_cnt = 0;
	scanf("%d %d", &N, &M);
	for (i = 1; i <= M; i++)
	{
		scanf("%d %d %d %d", &x, &y, &a, &b);
		sw[i] = (NODE){a, b, (NODE *)0x0};
		sw[i].next = Room[y][x].next;
		Room[y][x].next = &sw[i];
		/*
		if (Room[y][x].next == (NODE *)0x0) Room[y][x].next = &sw[i];
		else
		{
			sw[i].next = Room[y][x].next;
			Room[y][x].next = &sw[i];
			//for (head = Room[y][x].next; head->next; head = head->next);
			//head->next = &sw[i];
		}
		*/
	}
	room_cnt = 1;
	Room[1][1].flag = 1;	// 불 켜져 있음
	Visit[1][1] = 1;
}

void Print_Link(void)
{
	int i, j;
	NODE * k = (NODE *)0x0;

	printf("Print_Link\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			printf("y = %d, x = %d :", i, j);
			for (k = Room[i][j].next; k; k = k->next)
			{
				printf("yy = %d, xx = %d // ", k->y, k->x);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
}

void BFS_Switch_On(int sy, int sx)
{
	NODE * out = (NODE *)0x0;
	NODE * head = (NODE *)0x0;
	int i, d;
	int ny, nx, ni, nj;

	Wp = Rp = 0;
	for (head = Room[sy][sx].next; head; head = head->next)
	{
		if (Room[head->y][head->x].flag) continue;
		Room[head->y][head->x].flag = 1;
		room_cnt++;
	}
	InQ(sy, sx, Room[sy][sx].next);
	Visit[sy][sx] = 1;
	while (Wp != Rp)
	{
		out = OutQ();
		sy = out->y;		sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];		nx = sx + dx[i];
			if ( ny < 1 || ny > N || nx < 1 || nx > N ) continue;
			if ( Room[ny][nx].flag != 1 || Visit[ny][nx] ) continue;	// 꺼져있거나 이미 방문했으면 컨티뉴
			Visit[ny][nx] = 1;
			InQ(ny, nx, Room[ny][nx].next);
			for (head = Room[ny][nx].next; head; head = head->next)
			{
				if (Room[head->y][head->x].flag) continue;
				Room[head->y][head->x].flag = 1;
				room_cnt++;
				// [★★ 핵심 아이디어! ★★]
				// 이미 방문했던 곳인데, 쩌어엉 뒤에 있는 방에 불이 켜졌네?
				// 그렇다면 다시 돌아갈 필요 없이, 그 장소가 이미 방문했던 곳이랑 인접한지를 보고,
				// 인접했다면 그 좌표를 InQ해주면 방문표시로 연결될 것!!!!
				for (d = 0; d < 4; d++)
				{
					ni = head->y + dy[d];		nj = head->x + dx[d];
					if (ni < 1 || ni > N || nj < 1 || nj > N) continue;
					if ( Visit[ni][nj] )	// && Room[i][j].flag
					{
						InQ(ni, nj, Room[ni][nj].next);
					}
				}
			}
			
		}
	}
}

void InQ(int yy, int xx, NODE * nn)
{
	Que[Wp].y = yy;
	Que[Wp].x = xx;
	Que[Wp].next = nn;
	if (++Wp >= MAXQ) Wp -= MAXQ;
}

NODE * OutQ(void)
{ 
	if (Rp >= MAXQ) Rp -= MAXQ;
	return &(Que[Rp++]);
}

void Init_Struct_Visit(void)
{
	int i, j;
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			Visit[i][j] = 0;
			Room[i][j].flag = 0;
			Room[i][j].next = (NODE *)0x0;
		}
	}
	for (i = 1; i <= M; i++)
	{
		sw[i].y = sw[i].x = 0;
		sw[i].next = (NODE *)0x0;
	}
}

void Print_Flag(void)
{
	int i, j;

	printf("Switch On ?\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			printf("%d ", Room[i][j].flag);
		}
		printf("\n");
	}
	printf("\n");
}
#endif




// 20191015
// 문제 A5: [TEST] 7 segment
#if 0
#include <stdio.h>
#define INF	(10000000)

void Input(void);
void Make_Num(void);
void DFSA(int L);
void DFSB(int L);
void DFSC(int L);
void Print(void);
void Print_Impossible_Flag(void);

int digit[13][8];
int Chk_Num[10][8] = { { 0, 1, 1, 1, 1, 1, 1, 0 },	
					   { 0, 0, 0, 1, 1, 0, 0, 0 }, 
					   { 0, 0, 1, 1, 0, 1, 1, 1 },
					   { 0, 0, 1, 1, 1, 1, 0, 1 },
					   { 0, 1, 0, 1, 1, 0, 0, 1 }, 
					   { 0, 1, 1, 0, 1, 1, 0, 1 }, 
					   { 0, 1, 1, 0, 1, 1, 1, 1 }, 
					   { 0, 0, 1, 1, 1, 0, 0, 0 }, 
					   { 0, 1, 1, 1, 1, 1, 1, 1 },
					   { 0, 1, 1, 1, 1, 1, 0, 1 } };
int impossible_flag[13][10];	// 0 ~ 9
int possible_list[13][10];
int Min;
int ListA[8];
int A, B, C;

int main(void)
{
	freopen("in.txt", "r", stdin);

	Input();
	Make_Num();
	DFSA(1);
	//Print_Impossible_Flag();
	Print();

	return 0;
}

void Input(void)
{
	int i, j, r, c;

	A = B = C = 0;
	Min = INF;
	for (i = 1; i <= 12; i++)
	{
		for (j = 1; j <= 7; j++)
		{
			scanf("%1d", &digit[i][j]);
		}
		for (r = 0; r <= 9; r++)
		{
			for (c = 1; c <= 7; c++)
			{
				if ( digit[i][c] && !Chk_Num[r][c] )
				{
					impossible_flag[i][r] = -1;	// i번째 LED는 숫자 r이 될 수 없다는 의미!
				}
			}
		}
	}
}


void Make_Num(void)
{
	int i, j, cnt;

	for (i = 1; i <= 12; i++)
	{
		cnt = 0;
		for (j = 0; j <= 9; j++)
		{
			if (impossible_flag[i][j] == -1) continue;
			possible_list[i][++cnt] = j;
		}
		possible_list[i][0] = cnt;
	}
}

void Check_Result(void)
{
	int i, j, r, c;

	for (i = 1; i <= 12; i++)
	{
		for (r = 1; r <= possible_list[i][0]; r++)
		{

		}
	}
}

void DFSA(int L)
{
	int j;

	if ( L > 3 )
	{
		DFSB(4);
		return;
	}

	for (j = 1; j <= possible_list[L][0]; j++)
	{
		A = A * 10 + possible_list[L][j];
		DFSA(L + 1);
		A /= 10;
	}
}

void DFSB(int L)
{
	int j;

	if ( L > 6 )
	{
		DFSC(7);
		return;
	}

	for (j = 1; j <= possible_list[L][0]; j++)
	{
		B = B * 10 + possible_list[L][j];
		DFSB(L + 1);
		B /= 10;
	}
}

void DFSC(int L)
{
	int j;

	if (Min <= A * B) return;
	if ( L > 12 )
	{
		if ( A * B != C ) return;
		if (Min > C) Min = C;
		return;
	}

	for (j = 1; j <= possible_list[L][0]; j++)
	{
		C = C * 10 + possible_list[L][j];
		DFSC(L + 1);
		C /= 10;
	}
}

void Print(void)
{
	printf("%d\n", Min);
}

void Print_Impossible_Flag(void)
{
	int i, j;

	printf("Impossible Flag\n");
	for (i = 1; i <= 12; i++)
	{
		for (j = 0; j <= 9; j++)
		{
			printf("%3d", impossible_flag[i][j]);
		}
		printf("\n");
	}
	printf("\n");

	printf("possible list\n");
	for (i = 1; i <= 12; i++)
	{
		for (j = 0; j <= possible_list[i][0]; j++)
		{
			printf("%3d ", possible_list[i][j]);
		}
		printf("\n");
	}
}
#endif




// 20191015
// 문제 A6: [TEST] 사과나무
/*
	* 사실 N이 10밖에 안되기 때문에 비효율적인 코드라도 뭐 얼마나 비효율적이겠어?
	* 시작점(화재 발생 지역)이 여러개이기 때문에 벽 부수고 이동하기, 미로 탈출과 같은 방법으로 풀 수 없어. 아니 너무 어려워!! 
*/
#if 0
#include <stdio.h>

typedef struct { int y, x; }NODE;
NODE Apple[101];
NODE Fire[101];
NODE Que[288];
NODE List[3];

void Input(void);
void DFS(int L, int s_idx);
void InQ(int yy, int xx);
NODE * OutQ(void);
void Init_Visit(void);
void Print(void);
void Print_Map(void);

int N;
int Map[12][12];
int Visit[12][12];
int fire_cnt;
int apple_cnt;
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int Wp, Rp;
int max_tree;

int main(void)
{
	freopen("in.txt", "r", stdin);
	Input();
	DFS(0, 0);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	fire_cnt = apple_cnt = max_tree = 0;
	scanf("%d", &N);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &Map[i][j]);
			if (Map[i][j] == 2)
			{
				Fire[fire_cnt++] = (NODE){ i, j };
			}
			else if (Map[i][j] == 1)
			{
				Apple[apple_cnt++] = (NODE){ i, j };
			}
		}
	}
}

void DFS(int L, int s_idx)
{
	int i, r;

	if (L > 2) return;
	if (L <= 2)
	{
		//Print_Map();
		Init_Visit();
		r = BFS(L);
		if (max_tree < r) max_tree = r;
	}

	for (i = s_idx; i < apple_cnt; i++)
	{
		List[L] = Apple[i];
		Map[ Apple[i].y ][ Apple[i].x ] = 0;

		DFS(L + 1, i + 1);

		Map[ Apple[i].y ][ Apple[i].x ] = 1;
		List[L].y = 0;		List[L].x = 0;
	}
}

int BFS(int cnt)
{
	NODE * out = (NODE *)0x0;
	int i;
	int sy, sx, ny, nx;
	int tree_cnt = apple_cnt - cnt;

	Wp = Rp = 0;
	for (i = 0; i < fire_cnt; i++)
	{
		InQ(Fire[i].y, Fire[i].x);
		Visit[Fire[i].y][Fire[i].x] = 1;
	}

	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;		sx = out->x;
		for (i = 0; i < 4; i++)
		{
			ny = sy + dy[i];	nx = sx + dx[i];
			if (ny < 1 || ny > N || nx < 1 || nx > N || Visit[ny][nx]) continue;
			if (Map[ny][nx] == 1)
			{
				InQ(ny, nx);
				Visit[ny][nx] = 1;
				tree_cnt--;
			}
		}
	}

	return tree_cnt;
}

void InQ(int yy, int xx)
{
	Que[Wp].y = yy;
	Que[Wp++].x = xx;
}

NODE * OutQ(void) { return &(Que[Rp++]); }

void Init_Visit(void)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			Visit[i][j] = 0;
		}
	}
}

void Print(void)
{
	printf("%d\n", max_tree);
}

void Print_Map(void)
{
	int i, j;

	printf("Print_Map\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			printf("%2d ", Map[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}
#endif




// 20191015
// [BOJ. 16985] Maaaaaaaaaze
#if 0
#include <stdio.h>
#define MAX		(7)
#define MAXQ	(MAX*MAX*MAX)
#define INF		(987654321)

typedef struct { int z, y, x; }NODE;
NODE Que[MAXQ];
NODE start[4] = { { 1, 1, 1 }, { 1, 1, 5 }, { 1, 5, 1 }, { 1, 5, 5 } };
NODE end[4] = { { 5, 5, 5 }, { 5, 5, 1 }, { 5, 1, 5 }, { 5, 1, 1 } };

void Input(void);
void Operation(void);
void DFS(int L);
void Rotate_Arr(int num, int cnt);
void Copy_Map(void);
int BFS(int sz, int sy, int sx, int ez, int ey, int ex);
void InQ(int zz, int yy, int xx);
NODE * OutQ(void);
void Print(void);

int Map[MAX][MAX][MAX];
int Map2[MAX][MAX][MAX];
int chk2[MAX];
int dz[6] = { 0, 0, 0, 0, -1, 1 };
int dy[6] = { -1, 1, 0, 0, 0, 0 };
int dx[6] = { 0, 0, -1, 1, 0, 0 };
int move_cnt;
int Wp, Rp;

int main(void)
{
	freopen("in.txt", "r", stdin);

	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int z, y, x;

	move_cnt = INF;
	for (z = 1; z <= 5; z++)
	{
		for (y = 1; y <= 5; y++)
		{
			for (x = 1; x <= 5; x++)
			{
				scanf("%d", &Map[z][y][x]);
			}
		}
	}
}

void Copy_Map(void)
{
	int z, y, x;

	for (z = 1; z <= 5; z++)
	{
		for (y = 1; y <= 5; y++)
		{
			for (x = 1; x <= 5; x++)
			{
				Map2[chk2[z]][y][x] = Map[z][y][x];
			}
		}
	}
}

void DFS(int L)	// 순열
{
	int i, r, k;

	if (L > 5)
	{
		Copy_Map();
		for (k = 0; k < 4; k++)
		{
			if (!Map2[start[k].z][start[k].y][start[k].x] || !Map2[end[k].z][end[k].y][end[k].x]) continue;
			r = BFS(start[k].z, start[k].y, start[k].x, end[k].z, end[k].y, end[k].x);
			printf("r = %d\n", r);
			if (move_cnt > r) move_cnt = r;
		}
		return;
	}

	for (i = 1; i <= 5; i++)
	{
		if (chk2[i]) continue;
		chk2[L] = i;
		DFS(L + 1);
		chk2[L] = 0;
	}
}

void Operation(void)	// 순열 만들기! (0 ~ 3 사이)
{
	int a, b, c, d, e;

	for (a = 0; a < 4; a++)
	{
		Rotate_Arr(1, a);
		for (b = 0; b < 4; b++)
		{
			Rotate_Arr(2, b);
			for (c = 0; c < 4; c++)
			{
				Rotate_Arr(3, c);
				for (d = 0; d < 4; d++)
				{
					Rotate_Arr(4, d);
					for (e = 0; e < 4; e++)
					{
						Rotate_Arr(5, e);
						DFS(1);
						Rotate_Arr(5, 4 - e);
					}
					Rotate_Arr(4, 4 - d);
				}
				Rotate_Arr(3, 4 - c);
			}
			Rotate_Arr(2, 4 - b);
		}
		Rotate_Arr(1, 4 - a);
	}
}

void Rotate_Arr(int num, int cnt)	// Colckwise
{
	int y, x, c;
	int tmp[MAX][MAX] = { 0 };
	
	for (c = 0; c <= cnt; c++)
	{
		for (y = 1; y <= 5; y++)
		{
			for (x = 1; x <= 5; x++)
			{
				tmp[x][6 - y] = Map[num][y][x];
			}
		}
		for (y = 1; y <= 5; y++)
		{
			for (x = 1; x <= 5; x++)
			{
				Map[num][y][x] = tmp[y][x];
			}
		}
	}
}

int lcnt = 0;

int BFS(int sz, int sy, int sx, int ez, int ey, int ex)
{
	NODE * out = (NODE *)0x0;
	int i;
	int nz, ny, nx;
	int Visit[MAX][MAX][MAX] = { 0 };


	//printf("[ %d ] sz = %d, sy = %d, sx = %d // ez = %d, ey = %d, dx = %d\n", ++lcnt, sz, sy, sx, ez, ey, ex);
	Wp = Rp = 0;
	InQ(sz, sy, sx);
	Visit[sz][sy][sx] = 1;
	while (Wp > Rp)
	{
		//printf("Wp = %d, Rp = %d\n", Wp, Rp);
		out = OutQ();
		sz = out->z;	sy = out->y;	sx = out->x;
		for (i = 0; i < 6; i++)
		{
			nz = sz + dz[i];	ny = sy + dy[i];	nx = sx + dx[i];
			if ( nz < 1 || nz > 5 || ny < 1 || ny > 5 || nx < 1 || nx > 5 ) continue;
			if ( Map2[nz][ny][nx] == 1 && Visit[nz][ny][nx] == 0 )
			{
				Visit[nz][ny][nx] = Visit[sz][sy][sx] + 1;
				if (nz == ez && ny == ey && nx == ex)
				{
					//if (Visit[nz][ny][nx] - 1 == 0) printf("ez = %d, ey = %d, dx = %d\n", ez, ey, ex);
					return Visit[nz][ny][nx] - 1;
				}
				InQ(nz, ny, nx);
			}
		}
	}

	return INF;
}


void InQ(int zz, int yy, int xx)
{
	Que[Wp].z = zz;
	Que[Wp].y = yy;
	Que[Wp++].x = xx;
}

NODE * OutQ(void) { return &(Que[Rp++]); }

void Print(void)
{
	if (move_cnt == INF) move_cnt = -1;
	printf("%d\n", move_cnt);
}
#endif




// 20191015
// 마름모 찍기
#if 0
#include <stdio.h>
#define MAX	(52)

void Input(void);
void Operation(void);
void Print(void);

int N, Size;
int Map[MAX][MAX];

int main(void)
{
	freopen("in.txt", "r", stdin);

	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	scanf("%d %d", &N, &Size);
}

void Operation(void)
{
//	int y, x, i, r, c, step = 0;;

	int y = 5, x = 7;
	int i, r, c, step;
	int num = 0;

	for (i = 1; i <= Size; i++)
	{
		step = 0;
		num = 0;
		for (r = y - i; r <= y + i; r++)
		{
			for (c = x - step; c <= x + step; c++)
			{
				if ( Map[r][c] ) continue;
				Map[r][c] = ++num;
			}
			step += (r >= y) ? -1 : 1;
			printf("[r = %d]step = %d\n", r, step);
		}
	}
}

void Print(void)
{
	int i, j;

	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			printf("%d ", Map[i][j]);
		}
		printf("\n");
	}
}
#endif




// 20191015
// 페인트2
// 페인트 2 (idea)
#if 0
#include <stdio.h>
#define MAX_N (30)

int a[MAX_N][MAX_N];
int chk[MAX_N][MAX_N];
int N;
int size;
int gMAX;
int oneMAX;

int paint(int sY, int sX, int flag)
{
	int r, c, step = 0;
	int cnt = 0;
	for (r = sY - size; r <= sY + size; r++)
	{
		if (r<1 || r>N)
		{
			step += (r >= sY) ? -1 : 1;
			continue;
		}
		for (c = sX - step; c <= sX + step; c++)
		{
			if (c<1 || c>N) continue;
			if (a[r][c] || chk[r][c]) continue;
			chk[r][c] = flag;
			cnt++;
		}
		step += (r >= sY) ? -1 : 1;
	}

	/*
	for (r = 1; r <= 5; r++)
	{
		for (c = 1; c <= 5; c++)
		{
			printf("%d", chk[r][c]);
		}
		printf("\n");
	}
	*/
	return cnt;
}

void init_chk(void)
{
	int r, c;
	for (r = 1; r <= N; r++)
	{
		for (c = 1; c <= N; c++)
		{
			chk[r][c] = 0;
		}
	}
}

int findMax(void)
{
	int r1, c1, r2, c2;
	int cntA, cntT = 0;
	int max = 0;
	for (r1 = 1; r1 <= N; r1++)
	{
		for (c1 = 1; c1 <= N; c1++)	// 이중 for문을 돌며 모든 정점에 대해 그 정점이 마름모의 중심이라고 가정하고 찾아보자
		{
			cntA = paint(r1, c1, 1);	// (c1, r1)좌표를 중심으로 마름모를 그려보자
			if (cntA + oneMAX <= max)
			{
				init_chk();
				continue;
			}
			for (r2 = r1; r2 <= N; r2++)
			{
				for (c2 = 1; c2 <= N; c2++)
				{
					if (r1 == r2 && c1 >= c2) continue;
					cntT = cntA + paint(r2, c2, 0);
					if (max < cntT) {
						max = cntT;
						if (max == gMAX) return max;
					}
				}
			}
			init_chk();
		}
	}
	return max;
}

void input(void)
{
	int i, j;
	scanf("%d %d", &N, &size);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &a[i][j]);
		}
	}
	oneMAX = (size*size) + (size + 1) * (size + 1);	// 한 방울 떨어뜨렸을 때 최대 넓이 ( 마름모의 중심좌표를 뺀 나머지 넓이 )
	gMAX = oneMAX * 2;	// 그럼 두 방울 떨어뜨렸을 때의 최대 넓이는 이거겠지?
	//printf("%d, %d\n", oneMAX, gMAX);
}


int main(void)
{
	freopen("in.txt", "r", stdin);
	input();
	printf("%d\n", findMax());
	return 0;
}
#endif




// 20191016
// 문제 A8: [TEST] 곱셈
#if 0
#include <stdio.h>

void Input(void);
void DFS(int L);
int Operation(void);
void Print(void);
void Print_List(int L);

int N;
int Num[10];
int List[10];
int max_num;

int main(void)
{
	//freopen("in.txt", "r", stdin);
	Input();
	DFS(1);
	Print();
	return 0;
}

void Input(void)
{
	int i, tmp;

	max_num = 0;
	scanf("%d", &N);
	for (i = 1; i <= N; i++)
	{
		scanf("%d", &tmp);
		Num[tmp]++;
	}
}

void DFS(int L)
{
	int i, r;

	if (L > N)
	{
		//Print_List(L);
		r = Operation();
		//printf("r = %d\n", r);
		if (max_num < r) max_num = r;
		return;
	}

	for (i = 1; i <= 9; i++)
	{
		if (Num[i] == 0) continue;
		List[L] = i;	Num[i]--;
		DFS(L + 1);
		List[L] = 0;	Num[i]++;
	}
}

int Operation(void)
{
	int i, j, num1, num2, max, check;

	num1 = num2 = max = 0;
	for (i = 1; i < N; i++)
	{
		num1 = num1 * 10 + List[i];
		num2 = 0;
		for (j = i + 1; j <= N; j++)
		{
			num2 = num2 * 10 + List[j];
		}
		check = num1 * num2;
		if (max < check) max = check;
	}

	return max;
}

void Print(void)
{
	printf("%d\n", max_num);
}

void Print_List(int L)
{
	int i;

	printf("Print_List\n");
	for (i = 1; i < L; i++) printf("%2d", List[i]);
	printf("\n");
}
#endif



// 20191016
// 문제 A7: [TEST] 비행기 게임 - DFS ver.
/*
	* 모든 곳에 X가 깔려 있다고 한다면, 최대값이 음수가 나올 수도 있겠지?
*/
#if 0
#include <stdio.h>
#define MAX	(70)

typedef struct { int y, x, flag; }NODE;
NODE Enemy[MAX];

void Input(void);
void Operation(void);
void Clear_5Row(int y);
void DFS(int L, int y, int x, int score, int chk);
int Check_Node(int y, int x, int chk);
void Print(void);
void Init_Struct(void);
void Print_List(int L);
void Print_Flag(void);

int T;
char Map[15][7];
int dy[3] = { -1, -1, -1 };
int dx[3] = { -1, 0, 1 };
int enemy_cnt, coin;
int coin_list[15];
int enemy_list[15];
int max_score;
int flag;

int main(void)
{
	int i;

	//freopen("in.txt", "r", stdin);
	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Input();
		Operation();
		Print();
		Init_Struct();
	}

	return 0;
}

void Input(void)
{
	int i, j;
	char tmp[7];

	flag = 0;
	enemy_cnt = coin = 0;		 max_score = -987654321;
	for (i = 1; i <= 13; i++)
	{
		scanf("%s", tmp);
		for (j = 1; j <= 5; j++)
		{
			Map[i][j] = tmp[j - 1];
			if ( Map[i][j] == 'X' ) Enemy[++enemy_cnt] = (NODE){ i, j, 0 };
			else if (Map[i][j] == '*') coin++;
		}
	}
	coin *= 10;
}

void Operation(void)
{
	int i;

	for (i = 8; i >= 1; i--)
	{
		Clear_5Row(i);
		//Print_Flag();
		DFS(1, 13, 3, 0, i);
	}
}

void Clear_5Row(int y)
{
	int i;
	int min_row = y;
	int max_row = y + 4;
	
	for (i = 1; i <= enemy_cnt; i++)
	{
		if ( min_row <= Enemy[i].y && Enemy[i].y <= max_row ) Enemy[i].flag = y;
	}
}

void DFS(int L, int y, int x, int score, int chk)
{
	int i, ny, nx;

	if ( max_score >= score + (13 - L) * 10 ) return;
	if ( flag ) return;
	if (L > 12)
	{
		//Print_List(L);
		//printf("y = %d, x = %d\n", y, x);
		//printf("score = %d\n", score);
		if ( max_score < score ) max_score = score;
		if ( max_score == coin ) flag = 1;
		return;
	}

	for (i = 0; i < 3; i++)
	{
		ny = y + dy[i];		nx = x + dx[i];
		if ( nx < 1 || nx > 5 ) continue;
		if ( Map[ny][nx] == '*' ) coin_list[L] = 10;
		else if ( Map[ny][nx] == 'X' )
		{
			if ( Check_Node(ny, nx, chk) ) enemy_list[L] = -7;
		}
		DFS(L + 1, ny, nx, score + coin_list[L] + enemy_list[L], chk);
		coin_list[L] = enemy_list[L] = 0;
	}
}

int Check_Node(int y, int x, int chk)
{
	int i;

	for (i = 1; i <= enemy_cnt; i++)
	{
		if ( Enemy[i].y == y && Enemy[i].x == x && Enemy[i].flag == chk ) return 0;	// 점수 안 달어
	}
	return 1;	// 점수 달어
}

void Print(void)
{
	/*
	int i, j;

	for (i = 1; i <= 13; i++)
	{
		for (j = 1; j <= 5; j++)
		{
			printf("%c", Map[i][j]);
		}
		printf("\n");
	}
	*/
	printf("%d\n", max_score);
}

void Init_Struct(void)
{
	int i;

	for (i = 1; i <= enemy_cnt; i++) Enemy[i] = (NODE){ 0, 0, 0 };
}

void Print_List(int L)
{
	int i;

	printf("Print_List\n");
	for (i = 1; i <= L; i++) printf("[score = %d, enemy = %d]  ", coin_list[i], enemy_list[i]);
	printf("\n");
}

void Print_Flag(void)
{
	int i, j, k;

	printf("Print_Flag\n");
	for (i = 1; i <= 13; i++)
	{
		for (j = 1; j <= 5; j++)
		{
			if (Map[i][j] == 'X')
			{
				for (k = 1; k <= enemy_cnt; k++)
				{
					if ( Enemy[k].y == i && Enemy[k].x == j )
					{
						if (!Enemy[k].flag) printf("X");
						else printf("%d", Enemy[k].flag);
					}
				}
			}
			else printf("%c", Map[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}
#endif

// BFS ver.
#if 0
#include <stdio.h>
#define MAX	(65)
#define INF	(0x80000000)

typedef struct { int y, x; }NODE;
NODE Que[MAX * MAX];

void Input(void);
void Set_Data(void);
int BFS(int L);
void InQ(int yy, int xx);
NODE * OutQ(void);
void Print(void);
void Print_Map(void);

int T;
int Map[9][15][7];
int Visit[9][15][7];
int dy[3] = { -1, -1, -1 };
int dx[3] = { -1, 0, 1 };
int Wp, Rp;
int max_score;

int main(void)
{
	int i, j, r;

	freopen("in.txt", "r", stdin);
	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Input();
		Set_Data();
		//Print_Map();
		for (j = 1; j <= 8; j++)
		{
			r = BFS(j);
			if (max_score < r) max_score = r;
		}
		Print();
	}


	return 0;
}

void Input(void)
{
	int i, j;
	char tmp[10];

	for (i = 1; i <= 13; i++)
	{
		scanf("%s", &tmp[1]);
		for (j = 1; j <= 5; j++)
		{
			if (tmp[j] == '*') Map[0][i][j] = 10;
			else if (tmp[j] == 'X')	Map[0][i][j] = -7;
			else Map[0][i][j] = 0;
		}
	}
}

void Set_Data(void)	// 폭탄이 터질 경우에 맞는 3차원 배열 세팅
{
	int k, i, j;

	max_score = INF;
	for (k = 1; k <= 8; k++)
	{
		for (i = 1; i <= 13; i++)
		{
			for (j = 1; j <= 5; j++)
			{
				Visit[k][i][j] = INF;			// Visit배열 초기화
				Map[k][i][j] = Map[0][i][j];	// 맵 초기화
			}
		}
	}

	for (k = 1; k <= 8; k++)
	{
		for (i = k; i <= k + 4; i++)
		{
			for (j = 1; j <= 5; j++)
			{
				if (Map[k][i][j] == -7) Map[k][i][j] = 0;
			}
		}
	}
}

int BFS(int L)
{
	NODE * out = (NODE *)0x0;
	int i, sy, sx, ny, nx, max = INF, check;

	Wp = Rp = 0;
	InQ(13, 3);
	Visit[L][13][3] = 0;
	while (Wp > Rp)
	{
		out = OutQ();
		sy = out->y;	sx = out->x;
		if (sy == 1)
		{
			if (max < Visit[L][sy][sx]) max = Visit[L][sy][sx];
			continue;
		}
		for (i = 0; i < 3; i++)
		{
			ny = sy + dy[i];		nx = sx + dx[i];
			if (nx < 1 || nx > 5) continue;
			check = Visit[L][sy][sx] + Map[L][ny][nx];
			if (Visit[L][ny][nx] >= check) continue;
			Visit[L][ny][nx] = check;
			InQ(ny, nx);
		}
	}
	//printf("max = %d\n", max);
	return max;
}

void InQ(int yy, int xx)
{
	Que[Wp].y = yy;
	Que[Wp++].x = xx;
}

NODE * OutQ(void) { return &(Que[Rp++]); }

void Print(void) { printf("%d\n", max_score); }

void Print_Map(void)
{
	int k, i, j;

	printf("Print_Map\n");
	for (k = 1; k <= 8; k++)
	{
		printf("[k = %d의 세계]\n", k);
		for (i = 1; i <= 13; i++)
		{
			for (j = 1; j <= 5; j++)
			{
				printf("%3d ", Map[k][i][j]);
			}
			printf("\n");
		}
		printf("\n");
	}
}
#endif



// 20191016
// 문제 A9: [TEST] 미사일
#if 0
#include <stdio.h>
#define ABS(a) ( ( (a) < 0 ) ? -(a) : (a) )
#define DIST(a, b, c, d)	( ( ABS( (a) - (b) ) ) + ( ABS( (c) - (d) ) ) )
#define INF	(987654321)

typedef struct { int y, x, Energy; }VS;
VS vs[20];
//VS vs2[20];

void Input(void);
//void Copy_VS(void);
void DFS(int L);
void Print(void);
void Print_Injub(void);
void Print_List(int L);

int VS_cnt;
int MS_cnt, MS_power, MS_Range;
int Injub[20][20];
int vcnt;
int List[6];
int min;

int main(void)
{
	freopen("in.txt", "r", stdin);

	Input();
	//Print_Injub();
	DFS(1);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	min = INF;
	scanf("%d", &VS_cnt);
	vcnt = VS_cnt;
	for (i = 1; i <= VS_cnt; i++)
	{
		scanf("%d %d %d", &vs[i].x, &vs[i].y, &vs[i].Energy);
		for (j = 1; j < i; j++)
		{
			Injub[i][j] = Injub[j][i] = DIST(vs[i].y, vs[j].y, vs[i].x, vs[j].x);
		}
	}
	scanf("%d %d %d", &MS_cnt, &MS_power, &MS_Range);
}

/*
void Copy_VS(void)
{
	int i;

	for (i = 1; i <= VS_cnt; i++) vs2[i] = vs[i];
}
*/

void DFS(int L)
{
	int i, j;

	if ( min == 0 ) return;
	if ( L > MS_cnt )
	{
		//Print_List(L);
		if ( min > vcnt ) min = vcnt;
		return;
	}
	
	for (i = 1; i <= VS_cnt; i++)
	{
		if (vs[i].Energy <= 0) continue;	// 이미 에너지가 다 떨어졌으므로 파괴되었음
		for (j = 1; j <= VS_cnt; j++)
		{
			if ( Injub[i][j] > MS_Range ) continue;
			if ( vs[j].Energy > 0 && vs[j].Energy <= MS_power ) vcnt--;
			vs[j].Energy -= MS_power;
		}
		List[L] = i;
		DFS(L + 1);
		List[L] = 0;
		for (j = 1; j <= VS_cnt; j++)
		{
			if ( Injub[i][j] > MS_Range ) continue;
			if ( vs[j].Energy <= 0 && vs[j].Energy + MS_power > 0 ) vcnt++;
			vs[j].Energy += MS_power;
		}
	}
}

void Print(void)
{
	printf("%d\n", min);
}

void Print_Injub(void)
{
	int i, j;

	printf("Print_Injub\n");
	for (i = 1; i <= VS_cnt; i++)
	{
		for (j = 1; j <= VS_cnt; j++)
		{
			printf("%4d", Injub[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}

void Print_List(int L)
{
	int i;

	printf("Print_List\n");
	for (i = 1; i < L; i++)
	{
		printf("%2d ", List[i]);
	}
	printf("\n");

}
#endif

// Re
#if 0
#include <stdio.h>
#define ABS(a) ( ( (a) < 0 ) ? -(a) : (a) )
#define DIST(a, b, c, d)	( ( ABS( (a) - (b) ) ) + ( ABS( (c) - (d) ) ) )

typedef struct { int y, x, Energy; }VS;
VS vs[20];
VS vs2[20];

void Input(void);
void DFS(int L);
void Copy_VS(void);
int Bomb(void);
void Print(void);
void Print_Injub(void);
void Print_List(int L);

int VS_cnt;
int MS_cnt, MS_power, MS_Range;
int Injub[20][20];
int List[6];
int max;

int main(void)
{
	//freopen("in.txt", "r", stdin);

	Input();
	//Print_Injub();
	DFS(1);
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	max = 0;
	scanf("%d", &VS_cnt);
	for (i = 1; i <= VS_cnt; i++)
	{
		scanf("%d %d %d", &vs[i].x, &vs[i].y, &vs[i].Energy);
		for (j = 1; j < i; j++)
		{	// 인접배열에 거리를 넣어줬음. (한 군함을 중심으로, 그 군함의 좌표에 미사일을 발사하는데
			//  그 좌표와 인접(미사일의 범위)한 군함은 데미지를 받으므로!!)
			Injub[i][j] = Injub[j][i] = DIST(vs[i].y, vs[j].y, vs[i].x, vs[j].x);
		}
	}
	scanf("%d %d %d", &MS_cnt, &MS_power, &MS_Range);
}

void DFS(int L)
{
	int i, r;

	if (L > MS_cnt)
	{
		//Print_List(L);
		Copy_VS();
		r = Bomb();
		//printf("r = %d\n", r);
		if (max < r) max = r;
		return;
	}

	for (i = 1; i <= VS_cnt; i++)
	{
		List[L] = i;
		DFS(L + 1);
		List[L] = 0;
	}
}

void Copy_VS(void)
{
	int i;

	for (i = 1; i <= VS_cnt; i++) vs2[i] = vs[i];
}

int Bomb(void)
{
	int i, j, cnt = 0;

	for (i = 1; i <= MS_cnt; i++)	// 미사일 발사 개수
	{
		if (vs2[ List[i] ].Energy <= 0) continue;
		vs2[ List[i] ].Energy -= MS_power;
		for (j = 1; j <= VS_cnt; j++)	// 군함 개수
		{
			if ( List[i] != j && Injub[ List[i] ][j] <= MS_Range)
			{
				if (vs2[j].Energy <= 0) continue;
				vs2[j].Energy -= MS_power;
			}
		}
	}
	for (i = 1; i <= VS_cnt; i++) if (vs2[i].Energy <= 0) cnt++;

	return cnt;
}

void Print(void)
{
	printf("%d\n", VS_cnt - max);
}

void Print_Injub(void)
{
	int i, j;
	printf("Print_Injub\n");
	for (i = 1; i <= VS_cnt; i++)
	{
		for (j = 1; j <= VS_cnt; j++)
		{
			printf("%4d ", Injub[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}

void Print_List(int L)
{
	int i, j;
	printf("Print_List\n");
	for (i = 1; i < L; i++) printf("%d ", List[i]);
	printf("\n");
}
#endif




// 20191016
// 문제 B0: [TEST] 페그 솔리테어
#if 0
#include <stdio.h>
#include <string.h>
#define MAX	(20)
#define INF	(987654321)

void Input(void);
void DFS(int L, int y, int x, int remain);
void Print(void);
void Print_Map(void);

int T;
char Map[MAX][MAX];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };	// 인접 체크
int ddy[4] = { -2, 2, 0, 0 };
int ddx[4] = { 0, 0, -2, 2 };	// 다음 칸 체크
int dd[4] = { 1, 0, 3, 2 };
int pin_cnt;
int result;

int main(void)
{
	int i, r, c, cnt = 0;

	freopen("in.txt", "r", stdin);
	
	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Input();
		for (r = 1; r <= 5; r++)
		{
			for (c = 1; c <= 9; c++)
			{
				if (Map[r][c] == 'o')
				{
					//printf("=====[%d]=====\n", ++cnt);
					DFS(1, r, c, pin_cnt);
					//printf("Back Tracking\n");
				}
			}
		}
		Print();
	}

	return 0;
}

void Input(void)
{
	int i, j;
	char tmp[100];

	result = INF;
	pin_cnt = 0;
	for (i = 1; i<= 5; i++)
	{
		scanf("%s", &tmp[1]);
		for (j = 1; j <= 9; j++)
		{
			Map[i][j] = tmp[j];
			if (tmp[j] == 'o') ++pin_cnt;
		}
	}
}

void DFS(int L, int y, int x, int remain)
{
	int i, ny, nx, nny, nnx, r, c;
	
	//Print_Map();
	
	if (result == 1) return;
	if (result > remain) result = remain;

	for (i = 0; i < 4; i++)
	{
		ny = y + dy[i];		nx = x + dx[i];
		nny = y + ddy[i];	nnx = x + ddx[i];
		if (Map[ny][nx] == 'o' && Map[nny][nnx] == '.')
		{
			Map[y][x] = '.';
			Map[ny][nx] = '.';
			Map[nny][nnx] = 'o';

			for (r = 1; r <= 5; r++)
			{
				for (c = 1; c <= 9; c++)
				{
					if (Map[r][c] == 'o') DFS(1, r, c, remain - 1);
					//printf("Back Tracking\n");
				}
			}

			Map[nny][nnx] = '.';
			Map[ny][nx] = 'o';
			Map[y][x] = 'o';
		}
	}
}

void Print(void)
{
	printf("%d %d\n", result, pin_cnt - result);
}

void Print_Map(void)
{
	int i, j;

	printf("Print_Map\n");
	for (i = 1; i <= 5; i++)
	{
		for (j = 1; j <= 9; j++)
		{
			printf("%c", Map[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}
#endif

// 구조체 사용 ver.
#if 0
#include <stdio.h>
#define INF	(987654321)

typedef struct { int y, x; }NODE;
NODE Pin[10];

void Input(void);
void DFS(int remain);
void Print(void);

char Map[7][11];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int ddy[4] = { -2, 2, 0, 0 };
int ddx[4] = { 0, 0, -2, 2 };
int pin_cnt;
int remain_pin;

int main(void)
{
	int T, i;

	freopen("in.txt", "r", stdin);
	scanf("%d", &T);
	for (i = 1; i <= T; i++)
	{
		Input();
		DFS(pin_cnt);
		Print();
	}

	return 0;
}

void Input(void)
{
	int i, j;
	char tmp[20];

	pin_cnt = 0;
	remain_pin = INF;
	for (i = 1; i <= 5; i++)
	{
		scanf("%s", &tmp[1]);
		for (j = 1; j <= 9; j++)
		{
			Map[i][j] = tmp[j];
			if (tmp[j] == 'o') Pin[++pin_cnt] = (NODE){ i, j };
		}
	}
}

void DFS(int remain)
{
	int i, d, y, x, ny, nx, nny, nnx;

	if ( remain_pin == 1 ) return;
	if ( remain_pin > remain ) remain_pin = remain;

	for (i = 1; i <= pin_cnt; i++)
	{
		y = Pin[i].y;		x = Pin[i].x;
		if (Map[y][x] != 'o') continue;
		for (d = 0; d < 4; d++)
		{
			ny = y + dy[d];		nx = x + dx[d];
			if ( Map[ny][nx] != 'o' ) continue;
			nny = y + ddy[d];	nnx = x + ddx[d];
			if (Map[nny][nnx] != '.') continue;

			Map[y][x] = '.';
			Map[ny][nx] = '.';
			Pin[i].y = nny;		Pin[i].x = nnx;
			Map[nny][nnx] = 'o';

			DFS(remain - 1);

			Pin[i].y = y;	Pin[i].x = x;
			Map[nny][nnx] = '.';
			Map[ny][nx] = 'o';
			Map[y][x] = 'o';
		}
	}
}

void Print(void)
{
	printf("%d %d\n", remain_pin, pin_cnt - remain_pin);
}
#endif




// 20191017
// 문제 B2: [TST] 로봇 과자 먹기
#if 0
#include <stdio.h>
#define ABS(a)				( ( (a) < 0 ) ? -(a) : (a) )
#define DIST(a, b, c, d)	( ABS((a) - (b)) + ABS((c) - (d)) )
#define INF					(987654321)

typedef struct { int y, x; }NODE;
NODE Robot[11], Snack[11];

void Input(void);
void DFS(int L, int sum);
void Print(void);
void Print_Injub(void);

int T;
int N;
int Injub[11][11];
int min_move;
int chk[11], List[11];

int main(void)
{
	int t;

	freopen("in.txt", "r", stdin);
	
	scanf("%d", &T);
	for (t = 1; t <= T; t++)
	{
		Input();
		DFS(1, 0);
		Print();
		//Print_Injub();
	}

	return 0;
}


void Input(void)
{
	int i, j;

	min_move = INF;
	scanf("%d", &N);
	for (i = 1; i <= N; i++) scanf("%d %d", &Snack[i].y, &Snack[i].x);
	for (i = 1; i <= N; i++)
	{
		scanf("%d %d", &Robot[i].y, &Robot[i].x);
		for (j = 1; j <= N; j++)
		{
			Injub[i][j] = DIST(Robot[i].y, Snack[j].y, Robot[i].x, Snack[j].x);
		}
	}
}

void DFS(int L, int sum)
{
	int i;

	if ( min_move <= sum ) return;
	if (L > N)
	{
		if (min_move > sum) min_move = sum;
		return;
	}

	for (i = 1; i <= N; i++)
	{
		if ( chk[i] ) continue;	// 이미 먹힌 과자라면 못 먹음
		chk[i] = 1;		List[L] = i;
		DFS(L + 1, sum + Injub[L][i]);
		List[L] = 0;	chk[i] = 0;
	}
}

void Print(void)
{
	printf("%d\n", min_move);
}

void Print_Injub(void)
{
	int i, j;
	printf("Print_Injub\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			printf("%2d ", Injub[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}
#endif




// 20191017
// 문제 B1: [TST]로봇
/*
	★★★★
	일반적인 4방체크에 더해 그 인접 정점으로 갈 때의 로봇이 가지고 있던 방향까지 고려해주어야 하므로,
	일반적인 2차원배열(좌표)에 더해 방향의 좋은 경험까지도 기록해줄 수 있도록 한 층을 더 쌓아야 함!!
	=> 3차원 Visit배열!!

	★★★★
	미로탈출과 비슷한 BFS, 3차원 Visit 배열 활용하는 문제다!!
	=> 여기에서는 Visit의 층이 폭탄의 수 (이 문제는 4방향)
*/
// 그래도 이건 잘 푼 것이 아님!!
#if 0
#include <stdio.h>
#define MAX	(110)
#define INF	(987654321)

typedef struct { int y, x, dir; }NODE;
NODE s, e;
NODE Que[MAX * MAX * MAX];

void Input(void);
void BFS(void);
void InQ(int yy, int xx, int dd);
NODE * OutQ(void);
int Chk_Last(int dir);
void Print(void);
void Print_Visit(void);

int M, N;
int Map[MAX][MAX];
int Visit[5][MAX][MAX];
int dy[5] = { 0, 0, 0, 1, -1 };
int dx[5] = { 0, 1, -1, 0, 0 };
int dl[5] = { 0, 4, 3, 1, 2 };
int dr[5] = { 0, 3, 4, 2, 1 };
int db[5] = { 0, 2, 1, 4, 3 };
int min_command;
int Wp, Rp;

int main(void)
{
	freopen("in.txt", "r", stdin);
	Input();
	BFS();
	//Print_Visit();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	min_command = INF;
	scanf("%d %d", &M, &N);
	for (i = 1; i <= M; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &Map[i][j]);
		}
	}
	scanf("%d %d %d", &s.y, &s.x, &s.dir);
	scanf("%d %d %d", &e.y, &e.x, &e.dir);
}

void BFS(void)
{
	NODE * out = (NODE *)0x0;
	int dir, i, j, sy, sx, sd;
	int ny, nx, r;

	for (dir = 1; dir < 5; dir++) for (i = 1; i <= M; i++) for (j = 1; j <= N; j++) Visit[dir][i][j] = INF;

	Wp = Rp = 0;
	InQ( s.y, s.x, s.dir );
	Visit[s.dir][s.y][s.x] = 0;
	while (Wp > Rp)
	{
		//printf("Wp = %d, Rp = %d\n", Wp, Rp);
		out = OutQ();
		sy = out->y;	sx = out->x;	sd = out->dir;
		if (sy == e.y && sx == e.x)
		{
			r = Chk_Last(sd);
			if (min_command > Visit[sd][sy][sx] + r) min_command = Visit[sd][sy][sx] + r;
		}
		for (i = 1; i < 5; i++)
		{
			for (j = 1; j <= 3; j++)
			{
				ny = sy + dy[i] * j;	nx = sx + dx[i] * j;
				if (ny < 1 || ny > M || nx < 1 || nx > N || Map[ny][nx]) break;
				if ( Map[ny][nx] ) break;
				if ( sd == i )
				{
					if (Visit[i][ny][nx] <= Visit[sd][sy][sx] + 1) continue;
					Visit[i][ny][nx] = Visit[sd][sy][sx] + 1;
				}
				else if ( dl[sd] == i || dr[sd] == i )
				{
					if (Visit[i][ny][nx] <= Visit[sd][sy][sx] + 2) continue;
					Visit[i][ny][nx] = Visit[sd][sy][sx] + 2;
				}
				else if ( db[sd] == i )
				{
					if (Visit[i][ny][nx] <= Visit[sd][sy][sx] + 3) continue;
					Visit[i][ny][nx] = Visit[sd][sy][sx] + 3;
				}
				InQ(ny, nx, i);
			}
		}
	}
}

int Chk_Last(int dir)
{
	if ( dir == e.dir ) return 0;
	if ( dl[dir] == e.dir || dr[dir] == e.dir ) return 1;
	return 2;
}

void InQ(int yy, int xx, int dd)
{
	Que[Wp].y = yy;
	Que[Wp].x = xx;
	Que[Wp++].dir = dd;
}
NODE * OutQ(void)	 { return &(Que[Rp++]); }

void Print(void)
{
	printf("%d\n", min_command);
}

void Print_Visit(void)
{
	int k, i, j;

	printf("Print_Visit\n");
	for (k = 1; k < 5; k++)
	{
		for (i = 1; i <= M; i++)
		{
			for (j = 1; j <= N; j++)
			{
				if (Visit[i][j] == INF) printf(" X ");
				else printf("%2d ", Visit[k][i][j]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
}


// 직전에 짰던 개 더럽고 개 복잡하고 다신 이렇게 하면 안되겠다고 생각할만한 풀이..!!
/*
while (Wp > Rp)
{
//printf("Wp = %d, Rp = %d\n", Wp, Rp);
out = OutQ();
sy = out->y;	sx = out->x;	sd = out->dir;
//printf("y = %d, x = %d, dir = %d, com = %d\n\n", sy, sx, sd, Visit[sy][sx]);
if (sy == e.y && sx == e.x)
{
r = Visit[sy][sx];
if (sd == e.dir)
{
if (min_command > r) min_command = r;
}
else if (dl[sd] == e.dir)
{
if (min_command > r + 1) min_command = r + 1;
}
else if (dl[dl[sd]] == e.dir)
{
if (min_command > r + 2) min_command = r + 2;
}
else if (dr[sd] == e.dir)
{
if (min_command > r + 1) min_command = r + 1;
}
continue;
}
for (i = 1; i < 5; i++)	// i 방향을 체크하는 중 (Map 기준)
{
ny = sy + dy[i];		nx = sx + dx[i];
if ( ny < 1 || ny > M || nx < 1 || nx > N || Map[ny][nx] ) continue; // 먼저 그 방향이 1로 막혀있는지 확인!

printf("현재 위치 좌표 : y = %d, x = %d\n", sy, sx);
printf("현재 바라보고 있는 방향 : %d\n", sd);
printf("현재 인접 체크하고 있는 방향 : %d\n\n", i);
getch();

nny = sy + ddy[i];		nnx = sx + ddx[i];
nnny = sy + dddy[i];	nnnx = sx + dddx[i];
// i방향의 바로 인접한 칸에 궤도가 설치되어 있다.
// 그런데 로봇이 그 방향을 바라보고 있다.
if (i == sd)
{
	// 이미 더 적은 Visit(명령 횟수)로 그 곳을 방문한 것이 아니라면, 가본다.
	if (Visit[ny][nx] > Visit[sy][sx] + 1)
	{
		Visit[ny][nx] = Visit[sy][sx] + 1;
		InQ(ny, nx, sd);
	}
	// 그런데 바로 인접한 칸이 아니라 Go k = 2(두 번째로 인접한 칸에 궤도 설치)?
	if (nny >= 1 && nny <= M && nnx >= 1 && nnx <= N && !Map[nny][nnx])
	{
		// 이미 더 적은 Visit(명령 횟수)로 그 곳을 방문한 것이 아니라면, 가본다.
		if (Visit[nny][nnx] > Visit[sy][sx] + 1)
		{
			Visit[nny][nnx] = Visit[sy][sx] + 1;
			InQ(nny, nnx, sd);
		}
		// 그런데 바로 인접한 칸이 아니라 Go k = 3(세 번째로 인접한 칸에 궤도 설치)?
		if (nnny >= 1 && nnny <= M && nnnx >= 1 && nnnx <= N && !Map[nnny][nnnx])
		{
			// 이미 더 적은 Visit(명령 횟수)로 그 곳을 방문한 것이 아니라면, 가본다.
			if (Visit[nnny][nnnx] > Visit[sy][sx] + 1)
			{
				Visit[nnny][nnnx] = Visit[sy][sx] + 1;
				InQ(nnny, nnnx, sd);
			}
		}
	}
}
else // 바로 i방향으로 인접한 칸에 궤도가 설치되어 있는데, 로봇은 그 방향을 바라보고 있지 않아. 그래도 그 방향 체크하는거 끝이니 이번에 보내야 함!
{
	if (dl[sd] == i)	// 왼쪽으로 한 번 틀었더니 같은 방향?
	{
		//printf("i = %d, sd = %d, dl[sd] = %d\n", i, sd, dl[sd]);
		if (Visit[ny][nx] > Visit[sy][sx] + 2)
		{
			Visit[ny][nx] = Visit[sy][sx] + 2;
			InQ(ny, nx, dl[sd]);
		}
		if (nny >= 1 && nny <= M && nnx >= 1 && nnx <= N && !Map[nny][nnx])
		{
			if (Visit[nny][nnx] > Visit[sy][sx] + 2)
			{
				Visit[nny][nnx] = Visit[sy][sx] + 2;
				InQ(nny, nnx, dl[sd]);
			}
			if (nnny >= 1 && nnny <= M && nnnx >= 1 && nnnx <= N && !Map[nnny][nnnx])
			{
				if (Visit[nnny][nnnx] > Visit[sy][sx] + 2)
				{
					Visit[nnny][nnnx] = Visit[sy][sx] + 2;
					InQ(nnny, nnnx, dl[sd]);
				}
			}
		}
	}
	else if (dl[dl[sd]] == i)		// 뒤 돌아야해?
	{
		if (Visit[ny][nx] > Visit[sy][sx] + 3)
		{
			Visit[ny][nx] = Visit[sy][sx] + 3;
			InQ(ny, nx, dl[dl[sd]]);
		}
		if (nny >= 1 && nny <= M && nnx >= 1 && nnx <= N && !Map[nny][nnx])
		{
			if (Visit[nny][nnx] > Visit[sy][sx] + 3)
			{
				Visit[nny][nnx] = Visit[sy][sx] + 3;
				InQ(nny, nnx, dl[dl[sd]]);
			}
			if (nnny >= 1 && nnny <= M && nnnx >= 1 && nnnx <= N && !Map[nnny][nnnx])
			{
				if (Visit[nnny][nnnx] > Visit[sy][sx] + 3)
				{
					Visit[nnny][nnnx] = Visit[sy][sx] + 3;
					InQ(nnny, nnnx, dl[dl[sd]]);
				}
			}
		}
	}
	else if (dr[sd] == i)		// 오른쪽으로?
	{
		if (Visit[ny][nx] > Visit[sy][sx] + 2)
		{
			Visit[ny][nx] = Visit[sy][sx] + 2;
			InQ(ny, nx, dr[sd]);
		}
		if (nny >= 1 && nny <= M && nnx >= 1 && nnx <= N && !Map[nny][nnx])
		{
			if (Visit[nny][nnx] > Visit[sy][sx] + 2)
			{
				Visit[nny][nnx] = Visit[sy][sx] + 2;
				InQ(nny, nnx, dr[sd]);
			}
			if (nnny >= 1 && nnny <= M && nnnx >= 1 && nnnx <= N && !Map[nnny][nnnx])
			{
				if (Visit[nnny][nnnx] > Visit[sy][sx] + 2)
				{
					Visit[nnny][nnnx] = Visit[sy][sx] + 2;
					InQ(nnny, nnnx, dr[sd]);
				}
			}
		}
	}
}
		}
	}
*/
#endif

// 다시 풀어봄! (다시 해봐야 함!)
#if 0
#include <stdio.h>
#define MAX	(110)
#define INF	(987654321)

typedef struct { int y, x, dir; }NODE;
NODE s, e;
NODE Que[MAX * MAX * MAX];

void Input(void);
void BFS(void);
void InQ(int yy, int xx, int dd);
NODE * OutQ(void);
int Chk_Last(int dir);
void Print(void);
void Print_Visit(void);

int M, N;
int Map[MAX][MAX];
int Visit[5][MAX][MAX];
int dy[5] = { 0, 0, 0, 1, -1 };
int dx[5] = { 0, 1, -1, 0, 0 };
int dl[5] = { 0, 4, 3, 1, 2 };
int dr[5] = { 0, 3, 4, 2, 1 };
int db[5] = { 0, 2, 1, 4, 3 };
int min_command;
int Wp, Rp;

int main(void)
{
	freopen("in.txt", "r", stdin);
	Input();
	BFS();
	//Print_Visit();
	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	min_command = INF;
	scanf("%d %d", &M, &N);
	for (i = 1; i <= M; i++)
	{
		for (j = 1; j <= N; j++)
		{
			scanf("%d", &Map[i][j]);
		}
	}
	scanf("%d %d %d", &s.y, &s.x, &s.dir);
	scanf("%d %d %d", &e.y, &e.x, &e.dir);
}

void BFS(void)
{
	NODE * out = (NODE *)0x0;
	int dir, i, j, sy, sx, sd;
	int ny, nx, r;

	Wp = Rp = 0;
	InQ(s.y, s.x, s.dir);
	Visit[s.dir][s.y][s.x] = 1;
	while (Wp > Rp)
	{
		//printf("Wp = %d, Rp = %d\n", Wp, Rp);
		out = OutQ();
		sy = out->y;	sx = out->x;	sd = out->dir;
		if (sy == e.y && sx == e.x)
		{
			r = Chk_Last(sd);
			
		}
		for (i = 1; i < 5; i++)
		{

		}
		for (i = 1; i < 5; i++)
		{
			for (j = 1; j <= 3; j++)
			{
				ny = sy + dy[i] * j;	nx = sx + dx[i] * j;
				if (ny < 1 || ny > M || nx < 1 || nx > N || Map[ny][nx]) break;
				if (Map[ny][nx]) break;
				if (sd == i)
				{
					if (Visit[i][ny][nx] <= Visit[sd][sy][sx] + 1) continue;
					Visit[i][ny][nx] = Visit[sd][sy][sx] + 1;
				}
				else if (dl[sd] == i || dr[sd] == i)
				{
					if (Visit[i][ny][nx] <= Visit[sd][sy][sx] + 2) continue;
					Visit[i][ny][nx] = Visit[sd][sy][sx] + 2;
				}
				else if (db[sd] == i)
				{
					if (Visit[i][ny][nx] <= Visit[sd][sy][sx] + 3) continue;
					Visit[i][ny][nx] = Visit[sd][sy][sx] + 3;
				}
				InQ(ny, nx, i);
			}
		}
	}
}

int Chk_Last(int dir)
{
	if (dir == e.dir) return 0;
	if (dl[dir] == e.dir || dr[dir] == e.dir) return 1;
	return 2;
}

void InQ(int yy, int xx, int dd)
{
	Que[Wp].y = yy;
	Que[Wp].x = xx;
	Que[Wp++].dir = dd;
}
NODE * OutQ(void)	 { return &(Que[Rp++]); }

void Print(void)
{
	printf("%d\n", min_command);
}

void Print_Visit(void)
{
	int k, i, j;

	printf("Print_Visit\n");
	for (k = 1; k < 5; k++)
	{
		for (i = 1; i <= M; i++)
		{
			for (j = 1; j <= N; j++)
			{
				if (Visit[i][j] == INF) printf(" X ");
				else printf("%2d ", Visit[k][i][j]);
			}
			printf("\n");
		}
		printf("\n");
	}
	printf("\n");
}
#endif




// 20191017
// 문제 B3: [TEST] 상자 포장하기
#if 0
#include <stdio.h>

void Input(void);
void DFS(int L, int prevA, int sumA, int prevB, int sumB, int s_idx);
void Print(void);

int T, N;
int Box[25];
int chk[25];
int ListA[25], ListB[25];
int max_sum;
int total_sum[25];

int main(void)
{
	int t;

	freopen("in.txt", "r", stdin);
	scanf("%d", &T);
	for (t = 1; t <= T; t++)
	{
		Input();
		DFS(1, 1001, 0, 0, 0, 1);
		Print();
	}
	
	return 0;
}


void Input(void)
{
	int i, j, tmp;

	max_sum = 0;
	scanf("%d", &N);
	for (i = 1; i <= N; i++)
	{
		scanf("%d", &tmp);
		Box[i] = tmp;
		for (j = i; j <= N; j++)
		{
			total_sum[j] += tmp;
		}
	}
	
}

void DFS(int L, int prevA, int sumA, int prevB, int sumB, int s_idx)
{
	int i;
	//printf("L = %d, prevA = %d, sumA = %d, prevB = %d, sumB = %d, s_idx = %d\n",
	//	L, prevA, sumA, prevB, sumB, s_idx);

	if (sumA + sumB + total_sum[N - L + 1] <= max_sum) return;
	if (L > N)
	{
		max_sum = total_sum[N];
		return;
	}
	if (s_idx > N)
	{
		if (max_sum < sumA + sumB) max_sum = sumA + sumB;
		return;
	}

	for (i = s_idx; i <= N; i++)
	{
		if (prevA > Box[i])
		{
			ListA[L] = Box[i];
			DFS(L + 1, Box[i], sumA + Box[i], prevB, sumB, i + 1);
			ListA[L] = 0;
		}
		if (prevB < Box[i])
		{
			ListB[L] = Box[i];
			DFS(L + 1, prevA, sumA, Box[i], sumB + Box[i], i + 1);
			ListB[L] = 0;
		}
	}
}

void Print(void)
{
	printf("%d\n", max_sum);
}
#endif




// 20191017
// 문제 B4: [TST] 미로탈출 게임(Basic)
#if 0
#include <stdio.h>
#define MAX	(55)
#define INF	(987654321)

typedef struct { int y, x; }NODE;
NODE Que[MAX * MAX];

void Input(void);
void DFS(int L, int y, int x, int cnt);
void Print(void);
void Print_Map(void);
void Print_Change(void);
void Print_Visit(void);

// 행: 파이프 번호, 열: 열려 있는 파이프
int pipe[7] = { 0, 0x5, 0xA, 0xC, 0x9, 0x3, 0x6 };
int N, M;
int Map[MAX][MAX];
int change[16][16];
int rot[13][4];
int Wp, Rp;
int Visit[MAX][MAX];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int cur[4] = { 1, 4, 2, 8 };
int next[4] = { 4, 1, 8, 2 };
int min_move;

int main(void)
{
	freopen("in.txt", "r", stdin);
	Input();
	DFS(1, 1, 1, 1);
	Print();
	//Print_Change();
	//Print_Visit();

	return 0;
}

void Input(void)
{
	int i, j, tmp;

	min_move = INF;
	scanf("%d %d", &N, &M);
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			scanf("%d", &tmp);
			Map[i][j] = pipe[tmp];
		}
	}
	
	change[5][10] = change[10][5] = 1;
	change[12][9] = change[9][12] = change[12][6] = change[6][12] = change[12][3] = change[3][12] = 1;
	change[9][3] = change[3][9] = change[6][9] = change[9][6] = 1;
	change[3][6] = change[6][3] = 1;
	/*
	rot[5][0] = rot[10][0] = 1;
	rot[5][1] = 10;	rot[10][1] = 5;
	rot[12][0] = rot[9][0] = rot[6][0] = rot[3][0] = 3;
	rot[12][1] = 3;	rot[12][2] = 6;	rot[12][3] = 9;
	rot[9][1] = 3;	rot[9][2] = 6;	rot[9][3] = 12;
	rot[6][1] = 3;	rot[6][2] = 9;	rot[6][3] = 12;
	rot[3][1] = 6;	rot[3][2] = 9;	rot[3][3] = 12;
	*/
}


void DFS(int L, int y, int x, int cnt)
{
	int i, j, ny, nx, tmp;
	/*
	Print_Map();
	printf("현재의 cnt = %d\n", cnt);
	getch();
	*/

	if (cnt >= min_move) return;
		
	for (i = 0; i < 4; i++)
	{
		ny = y + dy[i];		nx = x + dx[i];
		if ( ny < 1 || ny > N || nx < 1 || nx > M || Visit[ny][nx] ) continue;	// 범위 밖으로 나가거나 이미 방문했던 곳이면 못드감
		if ((Map[y][x] & cur[i]) == 0) continue;	// 현재의 파이프가 인접체크하는 쪽으로 열려있지 않으면 못드감
		if ((Map[ny][nx] & next[i]))	// 현재위치에서 인접체크하는 쪽으로 열려 있으면서, 그 칸에서도 현재 위치로 열려 있으면!
		{
			/*
			printf("L = %d, y = %d, x = %d, cnt = %d\n", L, y, x, cnt);
			printf("[dir = %d]ny = %d, nx = %d\n", i, ny, nx);
			getch();
			*/
			
			if ( ny == N && nx == M )	// 그게 출구라면 cnt 갱신 - 여기서 갱신해주는 것이 맞나? 비효율적이지 않을까?
			{
				if (min_move > cnt + 1) min_move = cnt + 1;
				continue;;
			}
			
			Visit[ny][nx] = 1;			// 방문체크
			DFS(L + 1, ny, nx, cnt + 1);
			Visit[ny][nx] = 0;			// 방문체크 풀어줌
		}
		else
		{
			for (j = 3; j <= 12; j++)
			{
				if (change[Map[ny][nx]][j] == 0) continue;	// 90도 회전할 수 없는 것이라면 못드감
				if ((j & next[i]))		// 90도 회전할 수 있는 파이프로 변했는데, 그것이 현재 위치에 열려있다면, 가봄
				{
					tmp = Map[ny][nx];
					Map[ny][nx] = j;
					Visit[ny][nx] = 1;
					//printf("Map[ny = %d][nx = %d] was changed. from %d to j = %d\n", ny, nx, tmp, j);
					DFS(L + 1, ny, nx, cnt + 1);
					Visit[ny][nx] = 0;
					Map[ny][nx] = tmp;
				}
			}
		}
	}
}

void Print(void)
{
	//int r = BFS();
	if (min_move == INF) min_move = 0;
	printf("%d\n", min_move);
}

void Print_Map(void)
{
	int i, j;
	printf("Print_Map\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			printf("%d ", Map[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}

void Print_Change(void)
{
	int i, j;
	printf("Print_Change\n");
	for (i = 3; i <= 12; i++)
	{
		for (j = 3; j <= 12; j++)
		{
			printf("%d ", change[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}

void Print_Visit(void)
{
	int i, j;
	printf("Print_Visit\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= M; j++)
		{
			printf("%d ", Visit[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}
#endif




// 20191017
// 4311. [연습문제] 오래된 스마트폰
#if 0
#include <stdio.h>
#define MAX		(1100)
#define MAXQ	(MAX * MAX * 5)
#define INF		(21)

enum OPER { PLUS = 1, MINUS = 2, MULTI = 3, DIV = 4};

void Input(void);
void Make_Operand(void);
int BFS(void);
int Get_Num(int op, int a, int b);
void Print_Operand(void);

int T, N, O, M, W;
int Num[MAX];
int Oper[5];
int Que[MAXQ];
int Touch[MAX];
int result;
int Wp, Rp;
int zero_flag;
int end_flag;

int main(void)
{
	int t, T;

	//freopen("in.txt", "r", stdin);
	scanf("%d", &T);
	for (t = 1; t <= T; t++)
	{
		Input();
		Make_Operand();
		//Print_Operand();
		if (end_flag)
		{
			printf("#%d %d\n", t, Touch[W]);
			continue;
		}
		result = BFS();
		if ( result >= M ) result = -1;
		else result++;					// 마지막으로 = 연산자를 넣어줘야 하기 때문!!
		printf("#%d %d\n", t, result);
	}

	return 0;
}

void Input(void)
{
	int i, num, tmp;

	for (i = 0; i < 1000; i++) Touch[i] = INF;	// 최대 클릭 횟수가 20까지니 그것보다 큰 수로 초기화!

	result = 0;
	zero_flag = end_flag = 0;
	scanf("%d %d %d", &N, &O, &M);
	for (i = 0; i < N; i++)
	{
		scanf("%d", &num);
		Num[i] = num;
		Touch[ num ] = 1;
		if (num == 0)
		{
			zero_flag = 1;	// 0을 Num[0]에 두기 위함!
			tmp = Num[0];
			Num[0] = Num[i];
			Num[i] = tmp;
		}
	}
	for (i = 1; i <= O; i++) scanf("%d", &Oper[i]);
	scanf("%d", &W);
}

void Make_Operand(void)
{
	int k, i, j, tmp = 0;
	int N_tmp = N;
	// 두 자리수 만들기
	for (i = zero_flag; i < N_tmp; i++)
	{
		tmp = Num[i];
		for (j = 0; j < N_tmp; j++)
		{
			tmp *= 10;
			tmp += Num[j];
			Touch[ tmp ] = 2;
			Num[N++] = tmp;
			tmp /= 10;
		}
	}
	// 세 자리수 만들기
	for (k = zero_flag; k < N_tmp; k++)
	{
		tmp = Num[k];
		for (i = 0; i < N_tmp; i++)
		{
			tmp *= 10;
			tmp += Num[i];
			for (j = 0; j < N_tmp; j++)
			{
				tmp *= 10;
				tmp += Num[j];
				Touch[ tmp ] = 3;
				Num[N++] = tmp;
				tmp /= 10;
			}
			tmp /= 10;
		}
	}

	if (Touch[W] < 4) end_flag = 1;	// 혹시 그냥 터치만으로 숫자를 만들 수 있다면 그것이 최소!! (연산자 들어가는 순간 최소가 4번!!)
}

// 모든 숫자들에 대해서 터치 횟수 최소값을 저장해줌 in Touch 배열(단, = 연산자는 고려하지 않기에 M - 1개까지!)
int BFS(void)
{
	int i, j, k, out, check, touch_check;

	Wp = Rp = 0;
	for (i = 0; i < N; i++) Que[Wp++] = Num[i];	// InQ
	while (Wp > Rp)
	{
		out = Que[Rp++];	// OutQ
		for (j = 0; j < N; j++)
		{
			for (k = 1; k <= O; k++)
			{
				check = Get_Num( Oper[k], out, Num[j] );
				if (check < 0 || check > 999) continue;
				touch_check = Touch[out] + Touch[ Num[j] ] + 1;	// 피연산자의 터치 횟수 + 연산자 터치 횟수
				if ( touch_check > M - 1 ) continue;
				if (Touch[ check ] > touch_check)
				{
					Touch[ check ] = touch_check;
					Que[Wp++] = check;
				}
			}
		}
	}

	//printf("Touch[%d] = %d\n", W, Touch[W]);
	return Touch[W];
}

int Get_Num(int op, int a, int b)
{
	switch (op)
	{
		case PLUS: return a + b;
		case MINUS:	return a - b;
		case MULTI: return a * b;
		default:
			if (b == 0) return -1;
			return a / b;
	}
	return -1;
}

void Print_Operand(void)
{
	int i;
	printf("Print_Operand\n");
	for (i = 0; i < N; i++)
	{
		printf("[%d] %3d ", Touch[Num[i]], Num[i]);
	}
	printf("\n");
}
#endif



// 20191018
// 문제 B5: [TST] 스타워즈
#if 0
#include <stdio.h>
#define MAX	(110)
#define INF	(200)

void Input(void);
void Operation(void);
int BFS(int s);
void Print(void);

int N, M, D;
int Injub[MAX][MAX];
int Que[MAX * 10];
int max_def;
int Wp, Rp;

int main(void)
{
	freopen("in.txt", "r", stdin);
	Input();
	Operation();
	Print();

	return 0;
}

void Input(void)
{
	int i;
	int n1, n2, d;

	scanf("%d %d %d", &N, &M, &D);
	for (i = 1; i <= M; i++)
	{
		scanf("%d %d %d", &n1, &n2, &d);
		Injub[n1][n2] = Injub[n2][n1] = d;
	}
}

void Operation(void)
{
	int i, j, r;

	max_def = 0;
	for (i = 1; i <= N; i++)
	{
		r = BFS(i);
		if ( max_def < r ) max_def = r;
	}
}

int BFS(int s)
{
	int i, nn, check, cnt;
	int Visit[MAX];

	for (i = 1; i <= N; i++) Visit[i] = INF;
	Wp = Rp = 0;
	Que[Wp++] = s;
	Visit[s] = 0;

	while (Wp > Rp)
	{
		nn = Que[Rp++];
		for (i = 1; i <= N; i++)
		{
			if ( Injub[nn][i] >= D || !Injub[nn][i] ) continue;
			check = Visit[nn] + Injub[nn][i];
			if (Visit[i] > check)
			{
				Visit[i] = check;
				Que[Wp++] = i;
			}
		}
	}

	//for (i = 1; i <= N; i++) printf("%2d ", Visit[i]);
	//printf("\n\n");
	cnt = 0;
	for (i = 1; i <= N; i++)
	{
		if (Visit[i] < D) cnt++;
	}

	return cnt;
}


void Print(void)
{
	/*
	int i, j;
	printf("Print_Injub\n");
	for (i = 1; i <= N; i++)
	{
		for (j = 1; j <= N; j++)
		{
			printf("%2d ", Injub[i][j]);
		}
			printf("\n");
	}
	printf("\n");
	*/
	printf("%d\n", max_def);
}
#endif




// 20191018
// 문제 B6: [TEST] 가스관
/*
		파이프 "하나"가 비었다고 문제의 조건에 나와있음.
		우선 M과 Z의 위치는 파이프에 당연히 연결이 되어 있을 것인데, 어느 방향으로 연결되어 있는지 몰라.
		그래서 '+'로 봐주고 어디랑 연결이 되었는지 보아줄 것!
		그런데 문제는 원래 연결되어 있어야 하는 부분뿐만 아니라 나머지 세 방향도 연결이 되어야 한다고 인식을 해주지 않아야 할 때!!
		하지만, 문제에서 중요한 것은 하나가 비었고, 그것은 필연적으로 다른 파이프 2개 이상과 연결이 되어야 함!!
		(M과 Z가 빠지면 안 될것이기 때문!!)
		근데 Z와 M과 연결이 되었는데 다른 파이프와 연결이 안 되었다면, 즉 한 부분만 연결이 되었다면 그것을 답으로 골라주면 안되기 때문에
		Check 함수에서 .을 리턴하였음!! 걔는 그냥 빈 칸이라고.
		★★★★★ 파이프는 모두 연결되어 있어야 하므로 주변에 2개 이상의 파이프가 분명 있다!! ★★★★★
*/
#if 0
#include <stdio.h>
#define MAX	(30)

void Input(void);
void Operation(void);
char Check(int num);
void Print(void);

int T, R, C;
int Map[MAX][MAX];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
int cur[9] = { 0, 4, 8, 0, 1, 0, 0, 0, 2 };
int next[4] = { 4, 1, 8, 2 };
int Wp, Rp;
int cy, cx, cs;
char r;

int main(void)
{
	int t;

	freopen("in.txt", "r", stdin);

	scanf("%d", &T);
	for (t = 1; t <= T; t++)
	{
		Input();
		Operation();
		Print();
	}

	return 0;
}

void Input(void)
{
	int i, j, c;
	char tmp[MAX];

	scanf("%d %d", &R, &C);
	for (i = 1; i <= R; i++)
	{
		scanf("%s", &tmp[1]);
		for (j = 1; j <= C; j++)
		{
			switch (tmp[j])
			{
				case 'M':
					c = 0xF;
					break;
				case 'Z':
					c = 0xF;
					break;
				case 124:
					c = 0x5;
					break;
				case '-':
					c = 0xA;
					break;
				case '+':
					c = 0xF;
					break;
				case '1':
					c = 0xC;
					break;
				case '2':
					c = 0x9;
					break;
				case '3':
					c = 0x3;
					break;
				case '4':
					c = 0x6;
					break;
				default:
					c = 0x0;
					break;
			}
			Map[i][j] = c;
		}
	}
}

void Operation(void)
{
	int i, j, d;
	int ny, nx;

	for (i = 1; i <= R; i++)
	{
		for (j = 1; j <= C; j++)	// 정점
		{
			if ( Map[i][j] == 0 )		// 근데 그 점이 '.'으로 표시가 되어 있다면?
			{
				cs = 0;
				for (d = 0; d < 4; d++)
				{
					ny = i + dy[d];		nx = j + dx[d];
					if (ny < 1 || ny > R || nx < 1 || nx > C) continue;
					cs += ( cur[ Map[ny][nx] & next[d] ] );
					//printf("Map[%d][%d] & next[%d] = %d\n", ny, nx, d, Map[ny][nx] & next[d]);
				}
				r = Check(cs);
				if ( r != '.' )
				{
					cy = i;		cx = j;
					//printf("cs = %d\n", cs);
					return;
				}
			}
		}
	}
}

char Check(int num)
{
	switch ( num )
	{
		case 3: return '3';
		case 5: return 124;
		case 6: return '4';
		case 9: return '2';
		case 0xA: return '-';
		case 0xC: return '1';
		case 0xF: return '+';
		default: return '.';
	}
}

void Print(void)
{
	/*
	int i, j;
	printf("Print_Map\n");
	for (i = 1; i <= R; i++)
	{
		for (j = 1; j <= C; j++)
		{
			printf("%2X " , Map[i][j]);
		}
		printf("\n");
	}
	printf("\n");
	*/
	printf("%d %d %c\n", cy, cx, r);
}
#endif




// 20191018
// 문제 B7: [TEST] 사격놀이
#if 0
#include <stdio.h>
#define MAX	(15)

void Input(void);

void Print(void);

int Y, X;
int Board[MAX][MAX];
int Visit[MAX][MAX];
int Score_RD[MAX];
int Score_LD[MAX];

int main(void)
{
	freopen("in.txt", "r", stdin);
	Input();

	Print();

	return 0;
}

void Input(void)
{
	int i, j;

	scanf("%d %d", &Y, &X);
	for (i = 1; i <= Y; i++)
	{
		for (j = 1; j <= X; j++)
		{
			scanf("%d", &Board[i][j]);
			Board[i][0] += Board[i][j];
			Board[0][j] += Board[i][j];
		}
	}
}

void Operation(void)
{
	int i, j;

	for (i = 1; i <= Y; i++)
	{
		
	}
	for (j = 1; j <= X; j++)
	{

	}
}

void Print(void)
{
	int i, j;
	printf("Print_Board\n");
	for (i = 0; i <= Y; i++)
	{
		for (j = 0; j <= X; j++)
		{
			printf("%2d ", Board[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}
#endif






// 201910
// [BOJ. 16988] Baaaaaaaaaduk2 (Easy)
#if 0
#include <stdio.h>

void Input(void);

void Print(void);

int main(void)
{


	return 0;
}

void Input(void)
{

}

void Print(void)
{

}
#endif
